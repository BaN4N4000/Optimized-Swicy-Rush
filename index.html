<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>Unis ‚Äî Swicy Rush</title>
<link rel="icon" type="image/png" href="images/favicon-32x32.png" sizes="32x32" />
<link href="https://fonts.googleapis.com/css2?family=Chewy&family=Luckiest+Guy&family=Fredoka+One&family=Baloo+2:wght@600&family=Bangers&family=Bubblegum+Sans&display=swap" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">


<style>
:root {
  --accent: #87ceeb;
  --pink: #ff4da6;
  --bg1: linear-gradient(135deg,#ffdde1,#ee9ca7);
  --fade-out-dur: 500ms;
  --fade-in-dur: 600ms;
}
body {
  padding-top: env(safe-area-inset-top);
  padding-bottom: env(safe-area-inset-bottom);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);
}
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background: var(--bg1); /* your gradient background */
  overflow: hidden;
}

body {
  display: flex;
  align-items: center;
  justify-content: center;
}

#appWrapper {
  width: 90%;   
  width: calc(100% - 5%);   
  max-width: 90;      
  height: 100%;
  min-height:90%;
  margin: 0 auto;           
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 0;
  box-sizing: border-box;
}

#gameWrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.1vh; 
  max-height: 100vh;   
}

#mainMenu {
  width: min(80vw, 400px);  
  height: min(95vh, 95vw);   
}

#gameContainer,
#musicPlayerBox {
  transform: scale(1);      
  transform-origin: center;   
} 

#innerBoard {
  margin-top:2%;
  width: min(95vw, 95vh, 95%);  
  aspect-ratio: 1 / 1;          
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}

#gameInfo {
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 80%;
  max-width: 600px;
  margin: 1vh 0;
  padding: 0.5em 2em;
  background: #f8f8f8;
  border-radius: 10px;
  font-size: 1rem;
  font-weight: bold;
  box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  box-sizing: border-box;
}

#gameInfo span {
  flex: 1;
  text-align: center;
  padding: 0 1em;
}

#gameInfo {
  background: transparent;
  box-shadow: none;
  margin-top: 1vh;
  margin-bottom: 1vh;
}

/* =========================
   2. Game Container and Board
========================= */
#gameContainer {
  display: none;
  z-index:20;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;  /* space things evenly */
  
  width: 90vw;        /* consistent width */
  max-width: 600px;   /* keeps it neat on desktop */
  height: auto;      /* always fits on screen */
  max-height: 100vh;
  min-height: 505px;
  position: relative;
  border-radius: 3%;
  background: #fff;
  box-shadow: 0 12px 30px rgba(0,0,0,0.2),
              0 -6px 14px rgba(255,255,255,0.8);
  box-sizing: border-box;
  overflow: hidden;   /* prevent scrollbars popping in */
  padding: 1em; 
  gap: 1em;
}


/*#boardWrap {
  position: absolute;
  top: 15%;
  bottom: 15%;
  left: 5%;
  right: 5%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}*/

#innerBoard {
  flex: 0 0 auto;
  aspect-ratio: 8 / 8;
  max-width: 90vw;
  max-height: 65vh; /* keep space for player */

/*Grid Attributes*/
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(8, 1fr);
  opacity:90%;
  gap: 0%;
  padding: 1%;
  
  
  border-radius: 3%;
  background: #7a657b !important;
  box-shadow: inset 0 2.5% 5% rgba(0,0,0,0.18),
              inset 0 -1.5% 3% rgba(0,0,0,0.08);
  box-sizing: border-box;
}


/* =========================
   3. Main Menu
========================= */
#mainMenu {
  position: relative;
  z-index: 20;
  aspect-ratio: 9 / 16;
  min-height: 500px;
  max-height: 650px;
  border-radius: 18px;
  background: rgba(255, 255, 255, 0.95);
  box-shadow: 0 12px 30px rgba(0, 0, 0, 0.18), 0 -6px 12px rgba(255, 255, 255, 0.6);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 0.8em 1.2em;
  box-sizing: border-box;
  margin: 0 auto;
  gap: 16px;
  overflow: hidden;
}

#mainMenu h1, #mainMenu h2 {
  margin: 0;
  line-height: 1.1;
  color: var(--pink);
  letter-spacing: 1px;
  text-align: center;
  top: 5%;
  text-overflow: ellipsis;
  white-space: nowrap;
}

#mainMenu .menuBtn {
  border-radius: 999px;
  font-size: 1.2rem; /* default font size for buttons */
  padding: 12px 24px; /* default padding */
  border: none;
  background-color: var(--pink);
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

#mainMenu .menuBtn:hover {
  background: #ff1a75; /* brighter pink like the title hover */
  color: #dark-pink;
  text-shadow: 0 0 15px #ff99cc, 0 0 25px #ff4da6; /* glow like title */
  animation: popBounce 0.4s ease; /* bounce animation */
  box-shadow: 0 0 12px 4px rgba(255, 77, 166, 0.6);
}

#gameTitle span {
  font-size: 5rem;
}

@media (max-width: 400px) {
  #mainMenu {
    min-height: 450px; /* allow smaller */
    padding: 24px 12px; /* tighter padding */
    gap: 8px;
  }

  #mainMenu .menuBtn {
    font-size: 1rem;
    padding: 6px 10px;
  }

  #gameTitle span {
    font-size: 3rem; /* still big but won‚Äôt crush the buttons */
  }
}

@media (max-width: 1920px) {
	#mainMenu {
		height: 80vh; /* Slightly reduce height for medium screens */
		padding: 50px 16px;
		gap: 14px;
	  }


	  #mainMenu .menuBtn {
		width: 80%; /* make buttons stretch across the width on medium screens */
	  }
	  #gameTitle span {
		font-size: 5rem;
	  }  
}


/* =========================
   4. Buttons
========================= */
.menuBtn {
  width: 100%;                  /* fill container width */
  max-width: 320px;             /* optional max width */
  padding: clamp(0.5rem, 1.5vw, 1rem);  /* scale padding */
  border-radius: 999px;
  border: none;
  background: var(--pink);
  color: white;
  font-weight: 700;
  font-size: clamp(12px, 3vw, 18px);   /* responsive font size */
  cursor: pointer;
  transition: transform 0.12s ease, background 0.12s;
  box-sizing: border-box;
}

.menuBtn:hover {
  background: #ff80c0;
  transform: translateY(-2px);
}

.btn-candy {
  border: none;
  border-radius: 50%;
  width: clamp(30px, 4vmin, 40px);  
  height: clamp(30px, 4vmin, 40px);
  font-size: clamp(8px, 2vmin, 15px);
  display: flex;
  justify-content: center;
  align-items: center;
  background: none; 
  color: var(--pink);
  cursor: pointer;
  transition: transform 0.2s ease;
}
.btn-candy:hover {
  transform: scale(1.1);
}
.btn-candy:active {
  transform: scale(0.95);
}
.btn-candy {
  padding: 0;        /* removes internal space */
  line-height: 1;    /* keeps icons centered */
}

#toggleMusicBtn {
  position: absolute;
  top: 0;
  right: 0;
  border-radius: 0 0 0 12px ;
  height:4%;
  padding: 0.5em 1em; 
  border: 0;
  background: var(--pink);
  color: white;
  font-weight: 700;
  font-size: clamp(5px, 2.5vw, 12px);
  cursor: pointer;
  transition: background 0.3s;
  
  display: flex;            
  justify-content: center; 
  align-items: center;     
  text-align: center;       
}

#backButton {
  position: absolute;
  top: 0;
  left: 0;
  border-radius: 0 0 12px 0;
  height:4%;
  padding: 0.5em 1em; 
  border: 0;
  background: var(--pink);
  color: white;
  font-weight: 700;
  font-size: clamp(5px, 2.5vw, 12px);
  cursor: pointer;
  transition: background 0.3s;
  
  display: flex;            
  justify-content: center; 
  align-items: center;     
  text-align: center;       
}

#backButton:hover {
  background: #ff80c0;
}

#mechanicsButton {
  bottom: 3%;
  align-items: center;
  border-radius: 12px 0 12px 0;
  height:4%;
  padding: 0.5em 1em; 
  border: 0;
  background: var(--pink);
  color: white;
  font-weight: 700;
  font-size: clamp(5px, 2.5vw, 12px);
  cursor: pointer;
  transition: background 0.3s;
  
  display: flex;            
  justify-content: center; 
  align-items: center;     
  text-align: center;       
}


/* =========================
   5. Tiles and Animations
========================= */
.tile {
  -ms-touch-action: none;
  -webkit-user-select: none;
  touch-action: none;
  background: none;
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
  transition: transform 0.12s ease, box-shadow 0.12s ease;
}
.tileImg {
  width: 90%;
  height: 90%;
  border-radius: 10px;
  object-fit: cover;
}

.tile.hint {
  animation: hintPulse 1s infinite alternate;
  box-shadow: 0 0 15px 5px yellow;
  border-radius: 10px;
}

@keyframes hintPulse {
  from { transform: scale(1); opacity: 1; }
  to   { transform: scale(1.15); opacity: 0.7; }
}

.tile.matching { animation: matchPop 0.4s ease forwards !important;}
@keyframes matchPop { 0%{transform:scale(1);opacity:1;}50%{transform:scale(1.2);opacity:.8;}100%{transform:scale(0);opacity:0;} }

.tile.dizzyChange { 
  animation: dizzyPop 0.4s ease forwards !important;
}

@keyframes dizzyPop {
  0%   { transform: scale(1); opacity: 1; }
  50%  { transform: scale(1.15); opacity: 0.6; }
  100% { transform: scale(0); opacity: 0; }
}


.tile.selected { box-shadow: 0 0 16px 6px rgba(135,206,250,0.8); }
.tile.shake { animation: shake 0.25s ease; }
@keyframes shake {0%,100%{transform:translateX(0);}25%{transform:translateX(-4px);}50%{transform:translateX(4px);}75%{transform:translateX(-2px);}}

@keyframes hoverPulse { 0%{box-shadow:0 0 6px 1px rgba(135,206,250,0.4);}50%{box-shadow:0 0 10px 2px rgba(135,206,250,0.6);}100%{box-shadow:0 0 6px 1px rgba(135,206,250,0.4);} }
@keyframes glowPulse { 0%{box-shadow:0 0 10px 2px rgba(135,206,250,0.6);}50%{box-shadow:0 0 16px 4px rgba(135,206,250,0.9);}100%{box-shadow:0 0 10px 2px rgba(135,206,250,0.6);} }

.tile:hover, .tile.selected { transform: scale(1.06); box-shadow: 0 0 12px 4px rgba(135,206,250,0.6); }
.tile:hover { animation: hoverPulse 0.6s infinite ease-in-out; }
.tile.selected { animation: glowPulse 1s infinite ease-in-out; }

/* üîπ Horizontal row clear effect */
@keyframes rowClear {
  0%   { background: lightpink; transform: scale(1); opacity: 1; }
  50%  { background: pink; transform: scale(1.2); opacity: 0.8; }
  100% { background: transparent; transform: scale(0.8); opacity: 0; }
}
.tile.row-clearing {
  animation: rowClear 0.6s ease forwards;
  z-index: 10;
}

/* üîπ Vertical column clear effect */
@keyframes colClear {
  0%   { background: lightpink; transform: scale(1); opacity: 1; }
  50%  { background: pink; transform: scale(1.2); opacity: 0.8; }
  100% { background: transparent; transform: scale(0.8); opacity: 0; }
}
.tile.col-clearing {
  animation: colClear 0.6s ease forwards;
  z-index: 10;
}

/* üîπ Row clear swish */
.tile.row-clearing::after {
  content: "";
  position: absolute;
  top: 50%;
  left: -100%;
  width: 300%;
  height: 30%;
  background: linear-gradient(
    to right,
    transparent,
    rgba(255, 105, 180, 0.8), /* HotPink */
    transparent
  );
  transform: translateY(-50%);
  animation: rowSwish 0.6s ease forwards;
  pointer-events: none;
  z-index: 20;
}

@keyframes rowSwish {
  0%   { left: -100%; opacity: 1; }
  100% { left: 100%;  opacity: 0; }
}

/* üîπ Column clear swish */
.tile.col-clearing::after {
  content: "";
  position: absolute;
  left: 50%;
  top: -100%;
  width: 30%;
  height: 300%;
  background: linear-gradient(
    to bottom,
    transparent,
    rgba(255, 105, 180, 0.8), /* HotPink */
    transparent
  );
  transform: translateX(-50%);
  animation: colSwish 0.6s ease forwards;
  pointer-events: none;
  z-index: 20;
}

@keyframes colSwish {
  0%   { top: -100%; opacity: 1; }
  100% { top: 100%;  opacity: 0; }
}


@keyframes wrappedClear {
  0% {
    background: #ffb6c1; /* light pink flash */
    transform: scale(1);
    opacity: 1;
    box-shadow: 0 0 10px 5px rgba(255,105,180,0.8); /* hotpink glow */
  }
  50% {
    background: #ff69b4; /* stronger pink */
    transform: scale(1.4);
    opacity: 0.8;
    box-shadow: 0 0 20px 10px rgba(255,20,147,0.9); /* deep pink glow */
  }
  100% {
    background: transparent;
    transform: scale(0.6);
    opacity: 0;
    box-shadow: none;
  }
}

.tile.wrapped-clearing {
  animation: wrappedClear 0.6s ease forwards;
  z-index: 20;
  border: lightpink; 
}

.tile.colorbomb-clearing {
  animation: colorBombClear 0.7s ease forwards;
  z-index: 40;
}

@keyframes colorBombClear {
  0%   { background: radial-gradient(circle, #ff69b4, #pink, #pink); transform: scale(1); opacity: 1; }
  50%  { background: radial-gradient(circle, #ff69b4, #pink, #pink); transform: scale(1.5); opacity: 0.9; }
  100% { background: transparent; transform: scale(0.6); opacity: 0; }
}

/* Popping animation (new spawns) */
@keyframes popSpawn {
  0%   { transform: scale(0); opacity: 0; }
  60%  { transform: scale(1.3); opacity: 1; }
  100% { transform: scale(1); opacity: 1; }
}

.tile.spawning {
  animation: popSpawn 0.35s ease-out;
}


@keyframes fallBounce {
  0%   { transform: translateY(calc(var(--fall-distance, 100%) * -1)); opacity: 0.8; filter: blur(1px); }
  70%  { transform: translateY(0); opacity: 0.7; filter: blur(0.5px); }
  85%  { transform: translateY(-6%); filter: blur(0.8px); }
  100% { transform: translateY(0); filter: blur(0); }
}

.tile.falling {
  opacity:0;
  animation: fallBounce 0.3s cubic-bezier(.25,1.3,.5,1) forwards;
}
/* =========================
   6. Floating Candies
========================= */
#floatingCandies {
  position: fixed;
  top: 0;
  width: 100vw;
  height: 100vh;
  pointer-events: none;
  overflow: hidden;
  z-index: 15;
}
.floating-candy {
  position: absolute;
  top: 5%;
  width: clamp(20px, 5vw, 50px);
  height: clamp(20px, 5vw, 50px);
  pointer-events: none;
  z-index: 10;
}
@keyframes rise {0%{transform:translate(0,100vh);opacity:0;}20%{opacity:1;}50%{transform:translate(20px,50vh);}100%{transform:translate(-10px,-50px);opacity:0;}}
@keyframes fall {0%{transform:translate(0,-50px);opacity:0;}20%{opacity:1;}50%{transform:translate(-15px,50vh);}100%{transform:translate(10px,100vh);opacity:0;}}

.floating-move {
  animation: floatMoveUp 1s ease-out forwards;
  white-space: nowrap;
  position:absolute; font-weight:800; color: #4dff4d; font-size:20px;
  pointer-events:none; animation: floatUp 0.8s ease forwards;
  text-shadow: 0 0 6px #4dff4d, 0 0 10px #ff4da6;
}
@keyframes floatMoveUp {
  from { transform: translate(-50%, 0) scale(1); opacity: 1; }
  to   { transform: translate(-50%, -60px) scale(1.05); opacity: 0; }
}

/* =========================
   7. Score, Timer, Moves and Mode Display
========================= */
#timerDisplay, #scoreDisplay, #movesDisplay, #modeDisplay {
  position: absolute;
  font-weight: 800;
  font-size: clamp(5px, 3vw, 18px);
  color: var(--pink);
  z-index: 5;
  text-align: center;
}


#timerDisplay { left: 8%; }
#scoreDisplay { right: 8%; }
#movesDisplay { left: 8%; }
#modeDisplay { left: 50%; transform: translateX(-50%); }

.time-warning {
  color: white !important;
  -webkit-text-stroke: 1px red;
  text-stroke: 1px white;
  animation: pulseGlow 1s infinite;
}
@keyframes pulseGlow {0%{transform:scale(1);text-shadow:0 0 4px red,0 0 6px red;}50%{transform:scale(1.1);text-shadow:0 0 12px red,0 0 18px red;}100%{transform:scale(1);text-shadow:0 0 4px red,0 0 6px red;}}

/* =========================
   8. Music Player
========================= */

#musicPlayerBox {   
  display: none;
  width: 90%;
  max-width: 600px;
  height: 50vmin;
  max-height: 120px;
  aspect-ratio: 4 / 1
  align-items: center;
  border-radius: 20px;
  background: #fff;
  box-shadow: 0 12px 30px rgba(0,0,0,0.2), 0 -6px 14px rgba(255,255,255,0.8);
  padding: 1em;
  flex-direction: column;
  gap: 0.5em;
  z-index: 25;
  box-sizing: border-box;
  margin: 0 0 2vh 0;
  justify-content: center;
  min-height:100px;
}
/*
#extraBox,#musicPlayerBox {   
  display: none;
  width: 90%;
  max-width: 600px;
  height: 50vmin;
  max-height: 130px;
  aspect-ratio: 4 / 1
  align-items: center;
  border-radius: 20px;
  background: #fff;
  box-shadow: 0 12px 30px rgba(0,0,0,0.2), 0 -6px 14px rgba(255,255,255,0.8);
  padding: 1em;
  flex-direction: column;
  gap: 0.5em;
  z-index: 25;
  border-radius: 20px;
  box-sizing: border-box;
  margin: 0 0 4vh 0; 
}*/

#playerWrapper {
  display: flex;
  flex-direction: row;
  justify-content: center;
  align-items: stretch; /* make them equal in height too */
  gap: 1rem;
  width: 100%;
  max-height: 130px;
  max-width: 800px;
  margin: 0 auto;
}

/* Small screens */
@media (max-width: 400px) {
  #musicPlayerBox {
    max-height: 120px;     /* smaller max height for mobile */
  }
}

.progress {
  flex: 0 0 auto;                       /* don‚Äôt let flex shrink it */
  width: 100%;
  min-height: 8px;                      /* absolute minimum */
  height: clamp(4px, 0.5vh, 6px);        /* responsive, ties to viewport height */
  margin: 8px 0;                        /* steady breathing room */
  border-radius: 4px;
  background: #ffb6c1;
  cursor: pointer;
  position: relative;
  overflow: visible;                    /* knob won‚Äôt get cut */
}

#progressBar {
  height: 100%;
  background: #ff4da6;
  border-radius: 4px;
  transition: width 0.1s linear;
}

#progressKnob {
  position: absolute;
  top: 50%;
  left: 0;                            /* will be moved by JS */
  width: clamp(10px, 1vh, 14px);      /* scales with screen */
  height: clamp(10px, 1vh, 14px);
  background: white;
  border: 2px solid #ff4da6;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;               /* knob won‚Äôt block clicks */
}



.music-box { width: 100%; background: #fff; border-radius: 16px; padding: 0; text-align: center; }
.btn-circle {
  border-radius: 50%;
  width: clamp(40px,6vmin,60px);
  height: clamp(40px,6vmin,60px);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(14px,2vmin,22px);
  margin: 1vmin;
  cursor: pointer;
  transition: transform 0.2s ease;
}
.btn-circle:hover { transform: scale(1.1); }

#volumeSlider {
  -webkit-appearance: none;
  width: 100%;                       
  max-width: clamp(40px, 15vw, 80px); 
  height: 0.5rem;
  border-radius: 999px;
  background: linear-gradient(90deg, #ff4da6, #ffb6c1);
  outline: none;
  transition: box-shadow 0.2s ease;
}


@media (max-width: 480px) {
  .with-iframe .music-player-right {
    display: none;
  }
}

#volumeSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: clamp(10px, 2.5vmin, 16px);
  height: clamp(10px, 2.5vmin, 16px);
  border-radius: 50%;
  background: white;
  border: 2px solid #ff4da6;
  cursor: pointer;
  transition: transform 0.15s ease;
  box-shadow: 0 0 0 10px transparent; 
}
#volumeSlider:hover::-webkit-slider-thumb {
  transform: scale(1.1);
}

#volumeSlider:focus::-webkit-slider-thumb {
  box-shadow: none;
  background: white;
  border: 2px solid #ff4da6;
}
.dropup {
  position: relative; 
  width: 100%;        
}

.dropup .dropdown-menu {
  width: 100%;
  max-width: 80%;
  max-height: 200px;
  border-radius: 0.5em;
  overflow-y: auto;
  overflow-x: hidden;
  background: #1c1c1c;

  /* prevent shifting */
  margin: 0;
  position: absolute; 
  left: 0;
}


.dropup .dropdown-item {
  color: #ff69b4;
  font-size: clamp(0.9rem, 1vw, 1rem);
  background: transparent;
  transition: background 0.2s, color 0.2s;
}

.dropup .dropdown-item:hover,
.dropup .dropdown-item:focus {
  background: #ff69b4;
  color: #1c1c1c;
}

/* Optional scroll bar */
.dropup .dropdown-menu::-webkit-scrollbar {
  width: 8px;
}
.dropup .dropdown-menu::-webkit-scrollbar-track {
  background: #1c1c1c;
  border-radius: 8px;
}
.dropup .dropdown-menu::-webkit-scrollbar-thumb {
  background-color: #ff69b4;
  border-radius: 8px;
  border: 2px solid #1c1c1c;
}

.dropup .dropdown-menu.show {
  width: 120% !important; 
  max-width: none;
}

.dropup .dropdown-toggle {
  display: flex;
  justify-content: center;  
  align-items: center;      
  gap: 0.3em;                
  width: 40px;              
  height: 30px;             
  padding: 0;               
}

/* Override Bootstrap's arrow positioning */
.dropup .dropdown-toggle::after {
  position: static; 
  margin-left: 0;   
  transform: none;
}

/* Pink border for the dropup button */
.btn-outline-secondary.dropdown-toggle {
  font-size: clamp(12px, 2.5vw, 16px);
  padding: 0.25em 0.5em;
  white-space: nowrap;
  border-color: #ff69b4;      
  color: #ff69b4;            
  background: transparent;      
  transition: all 0.2s;
}

.btn-outline-secondary.dropdown-toggle:hover,
.btn-outline-secondary.dropdown-toggle:focus {
  background-color: #ff69b4;  
  color: #1c1c1c;              
  border-color: #ff69b4;      
}

#songTitle {
    width: 95%;                           
    max-width: 400px;                     
    font-size: clamp(12px, 1.5vw, 13px);  
    margin: 1% auto 0 auto;
    text-align: center;
    border-radius: 0.5em;
    background: #f5f5f5;
    height: 3em;                
    line-height: 3em;            
    min-height: 2em;                      
    overflow: hidden;                     
    white-space: nowrap;                   
    text-overflow: ellipsis;

	display: flex;            
    align-items: center;       
    justify-content: center;   
}

.music-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: clamp(8px, 2vw, 20px); 
  margin: clamp(4px, 1vw, 12px) 0;
}

/*/* ---------------- Music Player Grid ---------------- */
.music-player-grid {
  display: grid;
  grid-template-columns: 1fr auto 1fr; 
  align-items: center;
  gap: 1rem;
  width: 100%;
  max-width: 580px; 
  max-height: 150px;
  margin: 0 auto;
  box-sizing: border-box;
  overflow: overflow;
}

/* LEFT: Volume */
.music-player-left {
  margin-left: 0;
  display: flex;
  justify-content: flex-start;    
  min-width: 0;
}

/* CENTER: Controls */
.music-player-center {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0.2rem;
  flex-wrap: nowrap;
  min-width: 0;
}

/* RIGHT: Dropup */
.music-player-right {
  display: flex;
  justify-content: flex-end;
  align-items: center;

}


/* =========================
   9. Modals and Overlays
========================= */
.overlay {
  position: fixed;
  top:0; left:0;
  width:100%; height:100%;
  display:flex;
  justify-content:center;
  align-items:center;
  background: rgba(0,0,0,0.4);
  backdrop-filter: blur(5px);
  z-index:9999;
}

.modal-body {
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  max-width:100%;
  margin:0 auto;
  box-sizing:border-box;
  text-align: center;
}

.modal-dialog {
  margin: auto;              
}

/* =========================
   10. Welcome Box and Candy Text
========================= */
/* Responsive welcome box, tied to game board size */
.welcome-box {
  transform: scale(0.8);
  overflow-y:auto;
  width: min(90vw, 90vh, 600px);  
  padding: clamp(0.5rem, 2vw, 0.8rem) clamp(1rem, 4vw, 1.5rem);
  border-radius: 1rem;
  background: rgba(255, 255, 255, 0.9);
  text-align: center;
  display: flex;
  max-height: 70vh;
  flex-direction: column;
  align-items: center;
  margin: auto;                   
  box-sizing: border-box;
}

.welcome-box h1 {
  font-size: clamp(1.2rem, 4vw, 2rem);  
}

.welcome-box h2 {
  font-size: clamp(1rem, 3.5vw, 1.5rem);
  line-height: 1.4;
  margin: 0.5em 0;
}

.welcome-box p {
  font-size: clamp(0.85rem, 3vw, 1.1rem);/
  line-height: 1.4;
  margin: 0.5em 0;
}



/* Responsive images */
.welcome-box img {
  max-width: 80%;
  height: auto;
  border-radius: 12px;
}

.candy-animation {
  display:flex;
  flex-wrap:wrap;
  justify-content:center;
  gap:0.5rem;
  margin:1rem 0;
}

.welcome-box button {
  font-size: clamp(0.9rem, 2.8vw, 1.05rem);  
  padding: clamp(0.4rem, 1.8vw, 0.7rem) clamp(0.8rem, 3.5vw, 1.2rem);
  border-radius: 0.6rem;               
  border: none;
  background: #ff6f91;                     
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s ease, background 0.3s ease;
  width: fit-content;                      
  max-width: 80%;
  margin: 0.5em 0;  /* don‚Äôt overflow */
}

/* Hover / tap effect */
.welcome-box button:hover {
  transform: scale(1.05);
  background: #ff4f70;
}

#saveNameBtn {
  font-size: clamp(0.9rem, 2.8vw, 1.05rem); 
  padding: clamp(0.4rem, 1.8vw, 0.7rem) clamp(0.8rem, 3.5vw, 1.2rem);
  border-radius: 0.6rem;               
  border: none;
  background: #ff6f91;                     
  color: white;
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s ease, background 0.3s ease;
  width: fit-content;                      
  max-width: 80%;
  margin: 0.5em 0; 
}

/* Hover / tap effect */
#saveNameBtn:hover {
  transform: scale(1.05);
  background: #ff4f70;
}




.candy-img { width:clamp(30px,5vw,50px); height:clamp(30px,5vw,50px); }

.candy-text {
  font-size: clamp(40px, 10vw, 80px);
  color: #ff4da6;
  margin: 5px 0;
  text-align: center;
}

.candy-animation {
  display: flex;
  gap: 10px;
}

.candy {
  font-size: 28px;
  display: inline-block;
  animation: bounceCandy 1s infinite ease-in-out;
}
.candy:nth-child(1) { animation-delay: 0s; }
.candy:nth-child(2) { animation-delay: 0.1s; }
.candy:nth-child(3) { animation-delay: 0.2s; }
.candy:nth-child(4) { animation-delay: 0.3s; }
.candy:nth-child(5) { animation-delay: 0.4s; }
.candy:nth-child(6) { animation-delay: 0.5s; }
.candy:nth-child(7) { animation-delay: 0.6s; }
.candy:nth-child(8) { animation-delay: 0.7s; }

@keyframes bounceCandy {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-12px) rotate(-10deg); }
}
#mechanicsModal .modal-dialog {
  max-width: 800px; /* adjust width as needed */
  width: 90%;       /* responsive for smaller screens */
}
  
  @keyframes floatUp {
    0% { transform: translateY(0); opacity: 1; }
    100% { transform: translateY(-28px); opacity: 0; }
  }
  
:root{
  --fade-out-dur: 300ms;
  --fade-in-dur: 300ms;
}

/* =========================
   11. Miscellaneous
========================= */

#shuffleOverlay {
  position:absolute;
  top:0; left:0; width:100%; height:100%;
  backdrop-filter: blur(6px);
  background: rgba(255,255,255,0.5);
  display:flex; justify-content:center; align-items:center;
  font-size:1.8rem; font-weight:700; color:var(--pink);
  z-index:50; border-radius:14px; text-align:center; padding:10px;
  opacity:0; pointer-events:none; transition:opacity 0.3s ease;
}

.floating-score {
  position:absolute; font-weight:800; color:var(--pink); font-size:20px;
  pointer-events:none; animation: floatUp 0.8s ease forwards;
  text-shadow:0 0 6px #fff, 0 0 10px #ff4da6;
}
@keyframes floatUp {0%{transform:translateY(0) scale(1);opacity:1;}50%{transform:translateY(-20px) scale(1.3);opacity:1;}100%{transform:translateY(-40px) scale(1);opacity:0;}}



/* Credits */
.credit-img {
  width: 60px;
  border-radius: 50%;
  margin-bottom: 0.5rem;
}

.candy-text span {
  display:inline-block;
  cursor:pointer;
  transition: color 0.3s ease, text-shadow 0.3s ease;
}
.candy-text span:hover {
  color:#ff1a75;
  text-shadow:0 0 15px #ff99cc,0 0 25px #ff4da6;
  animation: popBounce 0.4s ease;
}

@keyframes popBounce {
  0%   { transform: scale(1); }
  40%  { transform: scale(1.15); }
  60%  { transform: scale(0.95); }
  80%  { transform: scale(1.05); }
  100% { transform: scale(1); }
}

@keyframes popIn {
  0% { transform: scale(0) rotate(-30deg); opacity: 0; }
  50% { transform: scale(1.3) rotate(10deg); opacity: 1; }
  100% { transform: scale(1) rotate(0); opacity: 1; }
}

.candy-text.animate span {
  display: inline-block;
  color: #ff1a75; text-shadow: 0 0 15px #ff99cc, 0 0 25px #ff4da6;
  animation: popIn 1s forwards;
}

/* Delay each letter for wave effect */
.candy-text.animate span:nth-child(1) { animation-delay: 0s; }
.candy-text.animate span:nth-child(2) { animation-delay: 0.05s; }
.candy-text.animate span:nth-child(3) { animation-delay: 0.1s; }
.candy-text.animate span:nth-child(4) { animation-delay: 0.15s; }
.candy-text.animate span:nth-child(5) { animation-delay: 0.2s; }
.candy-text.animate span:nth-child(6) { animation-delay: 0.25s; }
.candy-text.animate span:nth-child(7) { animation-delay: 0.3s; }
.candy-text.animate span:nth-child(8) { animation-delay: 0.35s; }
.candy-text.animate span:nth-child(9) { animation-delay: 0.4s; }


.random-pop {
  display: inline-block;
  color: #ff1a75;
  animation: bounceCandy 0.4s ease;
}



    /* Font classes */
    .chewy    { font-family: 'Chewy', cursive; }
    .luckiest { font-family: 'Luckiest Guy', cursive; }
    .fredoka  { font-family: 'Fredoka One', cursive; }
    .baloo    { font-family: 'Baloo 2', cursive; }
    .bangers  { font-family: 'Bangers', cursive; }
    .bubble   { font-family: 'Bubblegum Sans', cursive; }


/* fade out (shrink + fade) */
@keyframes fadeOut {
  from { opacity: 1; transform: scale(1); filter: none; }
  to   { opacity: 0; transform: scale(0.6); filter: none; }
}
.fading-out {
  animation: fadeOut var(--fade-out-dur) forwards;
  transform-origin: center center;
  pointer-events: none; /* avoid clicks while animating */
}

/* fade in with glow pulse */
@keyframes fadeInGlow {
  0%   { opacity: 0; transform: scale(1.15); filter: drop-shadow(0 0 18px rgba(255,85,170,1)); }
  60%  { opacity: 1; transform: scale(0.98); filter: drop-shadow(0 0 10px rgba(255,120,190,0.8)); }
  100% { opacity: 1; transform: scale(1); filter: none; }
}
.fading-in {
  animation: fadeInGlow var(--fade-in-dur) forwards;
  transform-origin: center center;
  pointer-events: auto;
}

@keyframes glowPulse {
  0% { box-shadow: 0 0 10px 2px rgba(135, 206, 250, 0.6); }
  50% { box-shadow: 0 0 16px 4px rgba(135, 206, 250, 0.9); }
  100% { box-shadow: 0 0 10px 2px rgba(135, 206, 250, 0.6); }
}

@keyframes hoverPulse {
  0% { box-shadow: 0 0 6px 1px rgba(135, 206, 250, 0.4); }
  50% { box-shadow: 0 0 10px 2px rgba(135, 206, 250, 0.6); }
  100% { box-shadow: 0 0 6px 1px rgba(135, 206, 250, 0.4); }
}

/* SCROLL UI */
/* Ensure welcome-box scrolls */
.welcome-box {
  max-height: 80vh;                
  overflow-y: auto;
  -webkit-overflow-scrolling: touch; /* smooth scroll on iOS */
}

/* Chrome, Edge, Safari */
.welcome-box::-webkit-scrollbar {
  width: 6px; /* very slim */
}

.welcome-box::-webkit-scrollbar-track {
  background: transparent; /* no track background */
}

.welcome-box::-webkit-scrollbar-thumb {
  background-color: rgba(0,0,0,0.3); /* subtle gray thumb */
  border-radius: 3px;
  opacity: 0;                        /* hidden by default */
  transition: opacity 0.3s;
}

.welcome-box.scrolling::-webkit-scrollbar-thumb {
  opacity: 1; /* show only while scrolling */
}

.welcome-box::-webkit-scrollbar-thumb:hover {
  background-color: rgba(0,0,0,0.5); /* slightly darker on hover */
}

/* Firefox */
.welcome-box {
  scrollbar-width: none; /* hidden by default */
  scrollbar-color: rgba(0,0,0,0.3) transparent;
}
.welcome-box.scrolling {
  scrollbar-width: thin; /* appear thin when scrolling */
}

#youtubePlayerContainer {
  border-radius: 20px;
  width: 100%;
  height: 50vmin;     /* force visible height */
  max-height: 120px;
  background: #000;  /* black background like a video frame */
  overflow: hidden;
}

#youtubePlayer,
#youtubePlayer iframe {
  width: 100% !important;
  height: 100% !important;
  display: block;
  pointer-events: none;
}

.videoWrapper {
  position: relative;
  width: 100%;
  max-width: 400px;   /* optional cap */
  margin: 0 auto;     /* center horizontally */
  border-radius: 20px;
  overflow: hidden;   /* clip rounded corners */

  /* maintain aspect ratio like YouTube */
  aspect-ratio: 16 / 9;
  background: #000;   /* black frame when no video */
}

#videoPlayer {
  width: 100%;
  height: 100%;
  object-fit: cover;  /* fill the box */
  display: block;
  pointer-events: none;
  border-radius: 20px; /* redundant but safe */
}
#divider {
  display: flex;
  align-items: flex-start;   /* align tops */
  gap: 0.5rem;                 /* space between video + player */
  width: 95%;
  max-width: 95%;
}

/* Modal styling */
.leaderboard-modal {
  border-radius: 20px;
  background: linear-gradient(145deg, #ffe6f0, #fff);
  box-shadow: 0 8px 24px rgba(0,0,0,0.15);
}

/* Title */
.leaderboard-modal .modal-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: #ff4da6; /* candy pink */
}

/* Tabs */
.leaderboard-tabs .nav-link {
  border: none;
  padding: 0px 16px;
  font-weight: 600;
  color: #ff4da6;
  background: #f8f8f8;
  transition: all 0.2s ease;
}
.leaderboard-tabs .nav-link.active {
  background: #ff4da6;
  color: white;
  box-shadow: 0 4px 10px rgba(0,0,0,0.15);
}

/* Leaderboard table */
.leaderboard-table {
  border-radius: 0 0 20px 20px;
  overflow: hidden;
  box-shadow: 0 6px 16px rgba(0,0,0,0.1);
}
.leaderboard-table table thead {
  background: #ffb3d9;
  color: white;
  font-weight: 600;
}
.leaderboard-table table tbody tr:nth-child(1) {
  background: #fff0f5; /* gold highlight vibe */
  font-weight: bold;
}
.leaderboard-table table tbody tr:nth-child(2) {
  background: #f5f5f5;
}
.leaderboard-table table tbody tr:nth-child(3) {
  background: #fafafa;
}

#leaderboardModal .modal-dialog {
  max-width: 70vh !important;
}

#leaderboardModal .modal-body {
  max-height: 70vh;         
  overflow-y: auto;         
  padding: 0;              
}

#leaderboardTabContent {
  max-width: 100% !important;
  max-height: 100%;
  margin: 0 auto;                
  justify-content: center;       
  align-items: center;          
  flex-direction: column;       
}

.leaderboard-table table {
  width: 100%;
  table-layout: fixed; /* ensures columns share space evenly */
  height: 80%;
}
.leaderboard-table thead th {
  position: sticky;
  background: #ff4da6;     
  color: white;
  z-index: 2;
}

/* Compact rank 1‚Äì10 */
.leaderboard-table tbody tr:nth-child(-n+10) td {
  padding: 8px 6px;     
  font-size: 1rem;    
}

/* Keep header readable */
.leaderboard-table thead th {
  padding: 8px 10px;
  font-size: 0.9rem;
}


/* üì± On small screens: more compact */
@media (max-width: 576px) {
  .leaderboard-table {
    max-height: 90vh;      
  }
  .leaderboard-table table th,
  .leaderboard-table table td {
    padding: 6px;          
    font-size: 0.9rem;     
  }
}

/* Adjust columns for clarity */
.leaderboard-table th,
.leaderboard-table td {
  text-align: center;
  padding: 12px;
  word-wrap: break-word;
}

/* Give "Player" column more space */
.leaderboard-table th:nth-child(2),
.leaderboard-table td:nth-child(2) {
  width: 50%;
}

/* ü•á 1st place name (gold glow) */
.leaderboard-table tbody tr:nth-child(1) td:nth-child(2) {
  font-weight: 800;
  color: #ffbe10; /* gold text */
  animation: playerGlowGold 2s infinite alternate;
}
@keyframes playerGlowGold {
  from { text-shadow: 1px 1px 3px #000, 0 0 5px #ffd700, 0 0 10px #ffd700; }
  to   { text-shadow: 1px 1px 3px #000, 0 0 15px #ffec8b, 0 0 30px #ffd700; }
}

/* ü•à 2nd place name (skyblue) */
.leaderboard-table tbody tr:nth-child(2) td:nth-child(2) {
  font-weight: 800;
  color: white; /* light skyblue text */
  animation: playerGlowSilver 2s infinite alternate;
}
@keyframes playerGlowSilver {
  from { text-shadow: 1px 1px 3px #000, 0 0 5px #87ceeb, 0 0 10px #87ceeb; }
  to   { text-shadow: 1px 1px 3px #000, 0 0 15px #b0e0e6, 0 0 30px #87ceeb; }
}

/* ü•â 3rd place name (light brown/bronze) */
.leaderboard-table tbody tr:nth-child(3) td:nth-child(2) {
  font-weight: 800;
  color: #eca251; /* light brown text */
  animation: playerGlowBronze 2s infinite alternate;
}
@keyframes playerGlowBronze {
  from { text-shadow: 1px 1px 3px #000, 0 0 5px #cd853f, 0 0 10px #cd853f; }
  to   { text-shadow: 1px 1px 3px #000, 0 0 15px #deb887, 0 0 30px #cd853f; }
}

/* ü•á Gold */
.leaderboard-table tbody tr:nth-child(2) {
  background: linear-gradient(
    270deg,
    #fff8dc,
    #ffd700,
    #fff8dc
  );
  background-size: 400% 400%;
  animation: waveGold 2s ease infinite;
}
@keyframes waveGold {
  0%   { background-position: 0% 50%; box-shadow: 0 0 5px #ffd700; }
  50%  { background-position: 100% 50%; box-shadow: 0 0 30px #ffd700; }
  100% { background-position: 0% 50%; box-shadow: 0 0 5px #ffd700; }
}

/* ü•à Silver (light skyblue) */
.leaderboard-table tbody tr:nth-child(3) {
  background: linear-gradient(
    270deg,
    #e0f7ff,
    #87ceeb,
    #e0f7ff
  );
  background-size: 400% 400%;
  animation: waveSilver 2s ease infinite;
}
@keyframes waveSilver {
  0%   { background-position: 0% 50%; box-shadow: 0 0 5px #87ceeb; }
  50%  { background-position: 100% 50%; box-shadow: 0 0 30px #87ceeb; }
  100% { background-position: 0% 50%; box-shadow: 0 0 5px #87ceeb; }
}

/* ü•â Bronze */
.leaderboard-table tbody tr:nth-child(4) {
  background: linear-gradient(
    270deg,
    #fdf5e6,
    #cd7f32,
    #fdf5e6
  );
  background-size: 400% 400%;
  animation: waveBronze 2s ease infinite;
}
@keyframes waveBronze {
  0%   { background-position: 0% 50%; box-shadow: 0 0 5px #cd7f32; }
  50%  { background-position: 100% 50%; box-shadow: 0 0 30px #cd7f32; }
  100% { background-position: 0% 50%; box-shadow: 0 0 5px #cd7f32; }
}


#playerNameModalLabel {
  font-size: 1.5rem;
  font-weight: 700;
  color: #ff4da6; /* candy pink */
}

#yunhameme {
  position: relative;
}

#yunhameme::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  opacity: 0.2; /* adjust transparency */
  pointer-events: none; /* allow table interaction */
  z-index: 2;
  border-radius: 0 0 20px 20px;
}

#yunhameme::before {
  background-image: var(--tab-bg-image);
}

<!---->

/* =====================
   DARK MODE VARIABLES
===================== */
:root {
  --accent: #87ceeb;
  --pink: #ff4da6;
  --bg1: linear-gradient(135deg, #ffdde1, #ee9ca7);
  --surface: #ffffff;
  --surface-alt: #f8f8f8;
  --text: #111111;
}

body.dark-mode {
  --accent: #87ceeb;
  --pink: #ff4da6; /* keep candy pinks */
  --bg1: linear-gradient(135deg, #1a1a1d, #2a2a2e);
  --surface: #222222;
  --surface-alt: #2e2e2e;
  --text: #f0f0f0;
}

/* Apply variables */
body {
  background: var(--bg1) !important;
  color: var(--text) !important;
}

#mainMenu,
#gameContainer,
.welcome-box,
.leaderboard-modal,
#musicPlayerBox,
.modal-content {
  background: var(--surface) !important;
  color: var(--text) !important;
  box-shadow: 0 0 20px rgba(0,0,0,0.5);
}

#innerBoard {
  background: #2e2e2e;
}

#gameInfo {
  background: none;
  color: var(--text) !important;
}

#songTitle {
  background: var(--surface-alt) !important;
  color: var(--text) !important;
}

/* Ensure leaderboard text pops on dark */
.leaderboard-modal .modal-title,
.leaderboard-tabs .nav-link {
  color: var(--pink);
}

/* Keep buttons pink */
.menuBtn, #mechanicsButton, #backButton, #toggleMusicBtn {
  background: var(--pink) !important;
  color: #fff !important;
}

#darkModeSwitchWrapper {
  font-size: 1.2rem;
}

/* =====================
   DARK MODE TOGGLE SWITCH
===================== */

/* Wrapper for layout */
#darkModeSwitchWrapper {
  display: flex;
  align-items: center;
  position: absolute;
  top: 12px;
  right: 10px;
  z-index: 1000;
  font-size: clamp(16px, 3vw, 22px);
}

/* Reset the default checkbox */
#darkModeSwitchWrapper input[type="checkbox"] {
  scale:0.8;
  appearance: none;
  -webkit-appearance: none;
  width: clamp(50px, 10vw, 62px);
  height: clamp(24px, 5vw, 32px);
  border-radius: 999px;
  background: linear-gradient(135deg, #ff80c0, #ff4da6);
  cursor: pointer;
  position: relative;
  outline: none;
  transition: background 0.3s ease;
}

/* Slider knob */
#darkModeSwitchWrapper input[type="checkbox"]::before {
  content: "";
  position: absolute;
  width: clamp(16px, 4vw, 24px);   /* responsive width */
  height: clamp(16px, 4vw, 24px);  /* responsive height */
  border-radius: 50%;
  top: 50%;
  left: 4px;
  background: #fff;
  transform: translateY(-50%);
  transition: transform 0.3s ease;
}

/* Checked state ‚Üí knob slides right */
#darkModeSwitchWrapper input[type="checkbox"]:checked::before {
  transform: translate(30px, -50%);
}

/* Sun/Moon icons */
#darkModeSwitchWrapper .bi {
  position: absolute;
  right: 65px;          /* offset to the right of the toggle */
  font-size: 1.4rem;
  color: var(--pink);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

/* Inactive icons are hidden */
#darkModeSwitchWrapper .inactive {
  opacity: 0;
  transform: scale(0.7);
  pointer-events: none;
}

/* Modal backdrop */
.pause-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.pause-modal.hidden {
  display: none;
}

/* Modal box */
.pause-box {
  background: var(--pink);
  color: #fff;
  padding: 24px 32px;
  border-radius: 16px;
  text-align: center;
  box-shadow: 0 0 20px rgba(255, 77, 166, 0.7);
  animation: popIn 0.4s ease; /* reuse your popIn animation */
}

.pause-box h2 {
  margin: 0 0 12px;
}

.pause-box button {
  margin-top: 12px;
  padding: 10px 20px;
  border: none;
  border-radius: 999px;
  background: #fff;
  color: var(--pink);
  font-weight: bold;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.pause-box button:hover {
  transform: scale(1.1);
}

</style>
</head>
<body>
<div id="pauseModal" class="pause-modal hidden">
  <div class="pause-box">
    <h2>Game Paused</h2>
    <p>You‚Äôve been idle for 30 seconds.</p>
    <button id="resumeBtn">Resume</button>
  </div>
</div>
<!-- Welcome Overlay -->
<div id="leaderboard"></div>
<div id="welcomeOverlay" class="overlay">
  <div class="welcome-box">
    <h2><strong>Welcome to Swicy Rush</strong></h2>
    <p>
      <strong>Swicy Rush</strong> is a fan-made puzzle game inspired by <strong>UNIS</strong>!  
      Just like the girls‚Äô ‚ÄúSwicy‚Äù charm, the game is full of colorful fun, cheeky twists, and endless good vibes.  
    <br><br>
      Made by an Everafter and meant to be enjoyed by fellow Everafters, this game is our way of celebrating UNIS and sharing the joy they bring us every day.   
      <br><small>(We are not officially affiliated with UNIS or their management.)</small>
    </p>
    
    <div class="credits">
      <p><a style="color:var(--pink); text-decoration:none;" target="_blank" href="https://x.com/BaN4N4000"><img src="images/ban4n400.png" style="width:60px; height:60px;" alt="BaN4N4000"><br>
		<strong>Developed by: @BaN4N4000</a></strong>
      <br>
    
        <a style="color:var(--pink); text-decoration:none;" target="_blank" href="https://x.com/_8n0nx">Special thanks to @_8n0nx for the UNIS Pixel Art</a>
      </p>
	<a style="color:var(--pink); text-decoration:none;" target="_blank" href="https://x.com/_8n0nx">
    <div class="candy-animation">
      <img src="images/candy1.png" class="candy-img candy" alt="Candy 1">
      <img src="images/candy2.png" class="candy-img candy" alt="Candy 2">
      <img src="images/candy3.png" class="candy-img candy" alt="Candy 3">
      <img src="images/candy4.png" class="candy-img candy" alt="Candy 4">
      <img src="images/candy5.png" class="candy-img candy" alt="Candy 5">
      <img src="images/candy6.png" class="candy-img candy" alt="Candy 6">
      <img src="images/candy7.png" class="candy-img candy" alt="Candy 7">
      <img src="images/candy8.png" class="candy-img candy" alt="Candy 8">
    </div></a>
	<button id="closeWelcome">Start Game</button>
    </div>     
  </div>
</div>

<!-- Player Name Modal -->
<div class="modal fade" id="playerNameModal" tabindex="-1" aria-labelledby="playerNameModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content" style="border-radius:16px; max-width:90%; margin:auto;">
      <div class="modal-header">
        <h5 class="modal-title w-100 text-center" id="playerNameModalLabel">Enter Your Name</h5>
      </div>
      <div class="modal-body text-center">
        <input id="playerNameInput" type="text" value="Guest" 
               class="form-control text-center" style="max-width:200px; margin:auto;">
      </div>
      <div class="modal-footer justify-content-center">
        <button id="saveNameBtn" type="button" class="btn btn-primary">Continue</button>
      </div>
    </div>
  </div>
</div>

<!-- LEADERBOARD -->

<div class="modal fade" id="leaderboardModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content leaderboard-modal">
      <div class="modal-header border-0">
        <h5 class="modal-title w-100 text-center">üèÜ Leaderboard</h5>
		
      </div>
      <ul class="nav nav-tabs justify-content-center leaderboard-tabs" id="leaderboardTabs" role="tablist">
          <li class="nav-item" role="presentation">
            <button class="nav-link active" id="classic-tab" data-bs-toggle="tab" data-bs-target="#classic"
              type="button" role="tab">Classic</button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="hurry-tab" data-bs-toggle="tab" data-bs-target="#hurry"
              type="button" role="tab">Hurry Hurry</button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="dizzy-tab" data-bs-toggle="tab" data-bs-target="#dizzy"
              type="button" role="tab">Dizzy Dizzy</button>
          </li>
          <li class="nav-item" role="presentation">
            <button class="nav-link" id="swish-tab" data-bs-toggle="tab" data-bs-target="#swish"
              type="button" role="tab">Swish & Match</button>
          </li>
        </ul>
		
        <!-- Tabs -->
    <section id="yunhameme">
        <!-- Tab content -->
        <div class="tab-content" id="leaderboardTabContent">
          <!-- Classic -->
          <div class="tab-pane fade show active" id="classic" role="tabpanel" aria-labelledby="classic-tab">
            <div class="leaderboard-table">
              <table class="table text-center align-middle mb-0">
                <thead>
                  <tr><th>Rank</th><th>Player</th><th>Score</th></tr>
                </thead>
                <tbody id="leaderboard-classic-body"></tbody>
              </table>
            </div>
          </div>

          <!-- Hurry -->
          <div class="tab-pane fade" id="hurry" role="tabpanel" aria-labelledby="hurry-tab">
            <div class="leaderboard-table">
              <table class="table text-center align-middle mb-0">
                <thead>
                  <tr><th>Rank</th><th>Player</th><th>Score</th></tr>
                </thead>
                <tbody id="leaderboard-hurry-body"></tbody>
              </table>
            </div>
          </div>

          <!-- Dizzy -->
          <div class="tab-pane fade" id="dizzy" role="tabpanel" aria-labelledby="dizzy-tab">
            <div class="leaderboard-table">
              <table class="table text-center align-middle mb-0">
                <thead>
                  <tr><th>Rank</th><th>Player</th><th>Score</th></tr>
                </thead>
                <tbody id="leaderboard-dizzy-body"></tbody>
              </table>
            </div>
          </div>

          <!-- Swish -->
          <div class="tab-pane fade" id="swish" role="tabpanel" aria-labelledby="swish-tab">
            <div class="leaderboard-table">
              <table class="table text-center align-middle mb-0">
                <thead>
                  <tr><th>Rank</th><th>Player</th><th>Score</th></tr>
                </thead>
                <tbody id="leaderboard-swish-body"></tbody>
              </table>
            </div>
          </div>
        </div>
    </section>
      
    </div>
  </div>
</div>



<div id="floatingCandies"></div>
<div id="appWrapper">
<section id="mainMenu" aria-label="Main menu">

<div id="darkModeSwitchWrapper">
  <i class="bi bi-sun-fill" style="color:var(--pink);" id="sunIcon"></i>
  <i class="bi bi-moon-stars-fill inactive" style="color:var(--pink);" id="moonIcon"></i>
  <input type="checkbox" id="darkModeToggle">
</div>
  
  <h2 id="gameTitle" class="candy-text bangers">
    <span>S</span><span>w</span><span>i</span><span>c</span><span>y</span><span>R</span><span>u</span><span>s</span><span>h</span>
  </h2>
    <button id="classicBtn" class="menuBtn">Classic</button>
  <button id="hurryBtn" class="menuBtn">Hurry Hurry</button>
  <button id="dizzyBtn" class="menuBtn">Dizzy Dizzy</button>
  <button id="swishBtn" class="menuBtn">Swish and Match</button>
  <button id="mechanicsBtn" class="menuBtn">Mechanics</button>
  <button id="leaderBtn" class="menuBtn" data-bs-toggle="modal" data-bs-target="#leaderboardModal">Leaderboard</button>

  
</section>


<div class="modal fade" id="mechanicsModal" tabindex="-1" aria-labelledby="mechanicsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content" style="border-radius:16px;">
      <div class="modal-header">
        <h5 class="modal-title" id="mechanicsModalLabel">Game Mechanics</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
	  <a style="color:black" target="_blank" href="https://x.com/_8n0nx">
		<div class="candy-animation d-flex justify-content-center mb-3">
			<img src="images/candy1.png" class="candy-img candy" alt="Candy 1">
			<img src="images/candy2.png" class="candy-img candy" alt="Candy 2">
			<img src="images/candy3.png" class="candy-img candy" alt="Candy 3">
			<img src="images/candy4.png" class="candy-img candy" alt="Candy 4">
			<img src="images/candy5.png" class="candy-img candy" alt="Candy 5">
			<img src="images/candy6.png" class="candy-img candy" alt="Candy 6">
			<img src="images/candy7.png" class="candy-img candy" alt="Candy 7">
			<img src="images/candy8.png" class="candy-img candy" alt="Candy 8">
		</div></a>
		
		   <strong>Classic</strong>Match candies at your own pace.
		   <strong>Hurry Hurry</strong> Score as much as you can before time runs out!
		   <strong>Dizzy Dizzy</strong> Candies randomly shuffle, stay sharp!
		   <strong>Swish and Match</strong> Match special a Special Candy and get extra move! 
		   <p></p><p></p>      
		
		
		<a style="color:black; text-decoration:none;" target="_blank" href="https://x.com/BaN4N4000"><strong>Developed By:  @BaN4N4000</a></strong>
		<a style="color:black; text-decoration:none;" target="_blank"href="https://x.com/_8n0nx"><strong>Pixel Artist:  @_8n0nx</a></strong>

      </div>
      <div class="modal-footer">
        <button id="mechanicsButton" type="button" class="btn btn-primary" data-bs-dismiss="modal">OK</button>
      </div>
    </div>
  </div>
</div>


<section id="gameWrapper">
   <div id="boardWrap">
<!-- If you're reading these, you can enable testColorBomb button and its script below -->
<!--   <button id="testColorBomb">Trigger Color Bomb</button>-->
<div id="gameContainer" aria-hidden="true">
<button id="backButton">‚ùÆ‚ùÆ</button>
<!--  <button id="toggleMusicBtn">Music ‚ùØ‚ùØ</button> -->
  <!-- <button id="shuffleBtn" class="btn-candy">Shuffle</button> -->
<div id="shuffleOverlay">No more Tiles to Match!<br>Shuffling...</div>

    <div id="innerBoard" role="grid" aria-label="Game board"></div>	
	<div id="gameInfo">
	  <div id="timerDisplay">Time: ‚àû</div>
	  <div id="modeDisplay"></div>
	  <div id="scoreDisplay">Score: 0</div>
    </div>		
	<div id="divider">
	<div id="playerWrapper">
		<video id="videoPlayer" style="border-radius:20px; display:none; width:100%; max-height:120px;"></video>
		<div id="youtubePlayerContainer" style="width:100%; max-height:120px; display:none;">
		<div id="youtubePlayer"></div></div>
	</div>	

		<div id="musicPlayerBox" class="container">
			<h4 id="songTitle"></h4>	 
		  <audio id="audioPlayer" preload="auto"></audio>		
		  <!-- Progress bar -->
		
		  <div class="progress">
			<div id="progressBar" class="progress-bar bg-danger" style="width: 0%;"></div>
		  </div>
			<div class="music-player-grid">
			   
			  <!-- LEFT: Dropup -->
			  <div class="music-player-left" style="opacity:100%;">

				<!-- dynamically generated songs -->
				<div class="dropup">
				  <button style="width:20px" class="btn btn-sm btn-outline-secondary dropdown-toggle"  data-bs-toggle="dropdown">	
				  </button>
				  <ul class="dropdown-menu" id="songList">
				  </ul>
				</div>
								  
			  </div>
				<!-- CENTER: Music Controls -->
			  <div class="music-player-center">      
					<button class="btn-candy" id="prevBtn"><i class="bi bi-skip-backward-fill"></i></button>
					<button class="btn-candy" id="playBtn"><i class="bi bi-play-fill"></i></button>
					<button class="btn-candy" id="nextBtn"><i class="bi bi-skip-forward-fill"></i></button>
			  </div>

			  <!-- RIGHT: Volume -->		 
			  <div class="music-player-right" >
					
					<input type="range" id="volumeSlider" min="0" max="100" value="70">
				
				
			  </div>
			</div>
		</div>
	</div>

</div>
</div>
</section>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
  const SUPABASE_URL = "https://hbpozzrizbbpycwgdywi.supabase.co";   // üîπ Replace with your Project URL
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhicG96enJpemJicHljd2dkeXdpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg2Mzg1NTMsImV4cCI6MjA3NDIxNDU1M30.qozBD0aiQtbjwJaPFV0-35P5_T7I2VZC5I2GkDkkMls";                // üîπ Replace with your anon public key

  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>
<script>

document.addEventListener("DOMContentLoaded", () => {
  const musicPlayerBox = document.getElementById("musicPlayerBox");
  const youtubeContainer = document.getElementById("youtubePlayerContainer");

  function updateIframeState() {
    // check if YouTube player is showing (iframe inside or container visible)
    const hasIframe = youtubeContainer.querySelector("iframe") && 
                      youtubeContainer.style.display !== "none";

    if (hasIframe) {
      musicPlayerBox.classList.add("with-iframe");
    } else {
      musicPlayerBox.classList.remove("with-iframe");
    }
  }

  // Run on load
  updateIframeState();

  // Watch for iframe changes in youtubeContainer
  const observer = new MutationObserver(updateIframeState);
  observer.observe(youtubeContainer, { childList: true, subtree: true, attributes: true });
});




// LIGHT MODE = SWICY || DARK MODE = CURIOUS
const toggle = document.getElementById("darkModeToggle");
const sun = document.getElementById("sunIcon");
const moon = document.getElementById("moonIcon");
const title = document.getElementById("gameTitle");

const fadeOutDur = 500; // ms
const fadeInDur = 500;  // ms
const holdDur = 4000;   // ms each word stays visible

let loopTimer = null; // timeout holder

// Build text with letter spans + wave animation
function setTitle(text) {
  title.innerHTML = "";
  [...text].forEach((letter, i) => {
    const span = document.createElement("span");
    if (letter === " ") {
      span.innerHTML = "&nbsp;";
      span.classList.add("space");
    } else {
      span.textContent = letter;
      span.style.animationDelay = `${i * 0.05}s`;
    }
    title.appendChild(span);
  });
  title.classList.add("animate"); // keep glow
}

// Fade out ‚Üí replace text ‚Üí fade in
function swapTitle(newText) {
  title.classList.add("fading-out");
  title.style.setProperty("--fade-out-dur", fadeOutDur + "ms");

  setTimeout(() => {
    title.classList.remove("fading-out");
    setTitle(newText);

    title.classList.add("fading-in");
    title.style.setProperty("--fade-in-dur", fadeInDur + "ms");

    setTimeout(() => {
      title.classList.remove("fading-in");
      // keep .animate so glow stays
    }, fadeInDur);
  }, fadeOutDur);
}

// Loop between Curious and Swicy Rush (dark mode)
function startDarkModeLoop() {
  let showCurious = true;

  function cycle() {
    if (showCurious) {
      swapTitle("CURIOUS?");
    } else {
      swapTitle("Swicy Rush");
    }
    showCurious = !showCurious;

    const cycleDelay = fadeOutDur + fadeInDur + holdDur;
    loopTimer = setTimeout(cycle, cycleDelay);
  }

  cycle();
}

// Loop Swicy Rush only (light mode)
function startLightModeLoop() {
  function cycle() {
    swapTitle("Swicy Rush");

    const cycleDelay =  fadeInDur + holdDur;
    loopTimer = setTimeout(cycle, cycleDelay);
  }

  cycle();
}

// Clear any active loop
function stopLoop() {
  if (loopTimer) {
    clearTimeout(loopTimer);
    loopTimer = null;
  }
}

// Update icons + title depending on mode
function updateIconsAndTitle() {
  stopLoop(); // üõë always reset old loop first

  if (document.body.classList.contains("dark-mode")) {
    sun.classList.add("inactive");
    moon.classList.remove("inactive");
    startDarkModeLoop();
  } else {
    moon.classList.add("inactive");
    sun.classList.remove("inactive");
    startLightModeLoop();
  }
}

// Init ‚Üí start in light mode
document.body.classList.remove("dark-mode");
toggle.checked = false;
setTitle("Swicy Rush");
startLightModeLoop(); // run loop for light mode by default

// Toggle listener
toggle.addEventListener("change", () => {
  document.body.classList.toggle("dark-mode");
  updateIconsAndTitle();
});


/* ENABLE TEST COLOR BOMB remove / and *
document.getElementById("testColorBomb").addEventListener("click", () => {
  const randomVal = Math.floor(Math.random() * 8); // assuming 8 candy types
  activateColorBomb(0, 0, randomVal);
});*/
/*
let attemptIdleTimer;
const attemptIdleLimit = 20000; // 20 seconds without a move
const pauseModal = document.getElementById("pauseModal");
const resumeBtn = document.getElementById("resumeBtn");

function resetAttemptIdleTimer() {
  clearTimeout(attemptIdleTimer);
  attemptIdleTimer = setTimeout(() => {
    pauseCurrentMode();
    showPauseModal();
  }, attemptIdleLimit);
}

// Show modal
function showPauseModal() {
  pauseModal.classList.remove("hidden");
}

// Hide modal
function hidePauseModal() {
  pauseModal.classList.add("hidden");
}

// Resume button ‚Üí resume game + reset timer
resumeBtn.addEventListener("click", () => {
  hidePauseModal();
  resumeCurrentMode();    // your resume function
  resetAttemptIdleTimer(); // restart idle countdown
});*/

// ===== Global Vars =====
let gameLoopId;
let attemptIdleTimer;
const attemptIdleLimit = 30000; // 30 seconds
let isPaused = false;           // global pause flag
let activeMode = null;          // track current mode (dizzy, rush, curious)
let gameActive = false;


const pauseModal = document.getElementById("pauseModal");
const resumeBtn = document.getElementById("resumeBtn");

// ===== Idle Timer =====
function resetAttemptIdleTimer() {
  clearTimeout(attemptIdleTimer);
  console.log("‚è±Ô∏è Idle timer reset (waiting", attemptIdleLimit / 1000, "seconds)");

  attemptIdleTimer = setTimeout(() => {
    if (!gameActive) return; // üëà skip pause when in menu

    console.log("‚è∏Ô∏è Idle limit reached ‚Üí pausing game");
    showPauseModal();
    pauseGame();
  }, attemptIdleLimit);
}

// ===== Pause/Resume =====
function pauseGame() {
  isPaused = true; // mark paused
  cancelAnimationFrame(gameLoopId);
}

function resumeGame() {
  isPaused = false; // mark resumed
  gameLoopId = requestAnimationFrame(gameLoop);
  resetAttemptIdleTimer();
}

// ===== Pause Modal Control =====
function showPauseModal() {
  pauseModal.classList.remove("hidden");
}
function hidePauseModal() {
  pauseModal.classList.add("hidden");
}

// ===== Resume Button =====
resumeBtn.addEventListener("click", () => {
  console.log("‚ñ∂Ô∏è Resume clicked ‚Üí restarting game");
  hidePauseModal();
  resumeGame();
});

// ===== Game Loop =====
function gameLoop() {
  // update game state + draw game board
  gameLoopId = requestAnimationFrame(gameLoop);
}

// Show/Hide modal
function showPauseModal() {
  pauseModal.classList.remove("hidden");
}
function hidePauseModal() {
  pauseModal.classList.add("hidden");
}

// Resume button ‚Üí restart loop + reset timer
resumeBtn.addEventListener("click", () => {
  console.log("‚ñ∂Ô∏è Resume clicked ‚Üí restarting loop");
  hidePauseModal();
  resetAttemptIdleTimer();
  gameLoopId = requestAnimationFrame(gameLoop); // restart loop
});

function pauseGame() {
  isPaused = true;
  cancelAnimationFrame(gameLoopId);
}

function resumeGame() {
  isPaused = false; // üëà reset flag so Dizzy can spawn again
  gameLoopId = requestAnimationFrame(gameLoop);
  resetAttemptIdleTimer();
}

function gameLoop() {
  // update game state
  // draw game board
  gameLoopId = requestAnimationFrame(gameLoop);
}

//============= GAME MECHANICS ===============


const tabImages = {
  classic: 'images/classic.png',
  hurry: 'images/hurry.png',
  dizzy: 'images/dizzy.png',
  swish: 'images/swish.png'
};

const yunha = document.getElementById('yunhameme');
const tabs = document.querySelectorAll('#leaderboardTabs button');

tabs.forEach(tab => {
  tab.addEventListener('shown.bs.tab', (event) => {
    const targetId = event.target.dataset.bsTarget.substring(1); // e.g. 'classic'
    const img = tabImages[targetId];
    yunha.style.setProperty('--tab-bg-image', `url(${img})`);
  });
});

// Initialize the first tab
yunha.style.setProperty('--tab-bg-image', `url(${tabImages['classic']})`);

//shuffle tester
document.addEventListener("DOMContentLoaded", () => {
  const shuffleBtn = document.getElementById("shuffleBtn");

  if (shuffleBtn) {
    shuffleBtn.addEventListener("click", () => {
      showShuffleOverlay(800); // show overlay for 0.8s
      setTimeout(() => animateShuffleAndResolve(), 800); // wait, then animate & shuffle
    });
  }
});

document.addEventListener("DOMContentLoaded", () => {
  const toggleBtn = document.getElementById("toggleMusicBtn");
  const musicBox = document.getElementById("musicPlayerBox");

  toggleBtn.addEventListener("click", () => {
    if (musicBox.style.display === "none" || musicBox.style.display === "") {
      musicBox.style.display = "flex";   // or "block"
      toggleBtn.textContent = "Music ‚ùØ‚ùØ";
    } else {
      musicBox.style.display = "none";
      toggleBtn.textContent = "Music ‚ùØ‚ùØ";
    }
  });
  
  
});

const nameInput = document.getElementById("playerNameInput");

nameInput.addEventListener("focus", function () {
  if (this.value === "Guest") {
    this.value = "";   // clear it
  }
});

document.addEventListener("DOMContentLoaded", () => {
  const nameModalEl = document.getElementById("playerNameModal");


  nameModalEl.addEventListener("hidden.bs.modal", () => {
    showMenu();
  });
});

let playerName = "Guest";


function closeWelcomeOverlay() {

  document.getElementById("welcomeOverlay").style.display = "none";


  const nameModal = new bootstrap.Modal(document.getElementById('playerNameModal'));
  nameModal.show();
}


document.getElementById("closeWelcome").addEventListener("click", closeWelcomeOverlay);


document.getElementById("welcomeOverlay").addEventListener("click", function(e) {
  const welcomeBox = document.querySelector(".welcome-box");


  if (!welcomeBox.contains(e.target)) {
    closeWelcomeOverlay();
  }

});

document.addEventListener("keydown", function(e) {
  if (e.key === "Escape") {
    const overlay = document.getElementById("welcomeOverlay");
    if (overlay && overlay.style.display !== "none") {
      closeWelcomeOverlay();
    }
  }
});


document.getElementById("saveNameBtn").addEventListener("click", () => {
  const input = document.getElementById("playerNameInput").value.trim();
  playerName = input || "Guest";

 
  const nameModalEl = document.getElementById('playerNameModal');
  const modal = bootstrap.Modal.getInstance(nameModalEl);
  modal.hide();

 
  startMusic();

  
  const gameTitle = document.getElementById("gameTitle");
  const letters = gameTitle.querySelectorAll("span");

  gameTitle.classList.add("animate");

  setTimeout(() => {
    gameTitle.classList.remove("animate");
    let lastIndex = -1;
    setInterval(() => {
      let randomIndex;
      do {
        randomIndex = Math.floor(Math.random() * letters.length);
      } while (
        randomIndex === lastIndex ||
        letters[randomIndex].classList.contains("random-pop")
      );
      lastIndex = randomIndex;

      const randomLetter = letters[randomIndex];
      randomLetter.classList.add("random-pop");
      setTimeout(() => {
        randomLetter.classList.remove("random-pop");
      }, 500);
    }, 800);
  }, 1500);

 
  showMenu();
});


//Rise and Fall Candies
const candyImages = [
  'images/candy1.png','images/candy2.png','images/candy3.png',
  'images/candy4.png','images/candy5.png','images/candy6.png',
  'images/candy7.png','images/candy8.png'
];

function spawnCandy() {
  if (document.hidden) return;
  
  const candy = document.createElement('img');
  candy.src = candyImages[Math.floor(Math.random() * candyImages.length)];
  candy.className = 'floating-candy';

  const candyWidth = 40;
  candy.style.left = Math.random() * (window.innerWidth - candyWidth) + 'px';

 
  const direction = Math.random() < 0.5 ? 'fall' : 'rise';
  const duration = Math.random() * 5 + 5; // 5-10s

  candy.style.animation = `${direction} ${duration}s linear forwards`;

  document.getElementById("floatingCandies").appendChild(candy);

 
  candy.addEventListener('animationend', () => candy.remove());
}

setInterval(spawnCandy, 400);


function hasPossibleMoves() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const val = board[r][c];

 
      if (c < COLS - 1) {
        [board[r][c], board[r][c + 1]] = [board[r][c + 1], board[r][c]];
        if (findAllMatches().length > 0) {
          [board[r][c], board[r][c + 1]] = [board[r][c + 1], board[r][c]];
          return true;
        }
        [board[r][c], board[r][c + 1]] = [board[r][c + 1], board[r][c]];
      }

 
      if (r < ROWS - 1) {
        [board[r][c], board[r + 1][c]] = [board[r + 1][c], board[r][c]];
        if (findAllMatches().length > 0) {
          [board[r][c], board[r + 1][c]] = [board[r + 1][c], board[r][c]];
          return true;
        }
        [board[r][c], board[r + 1][c]] = [board[r + 1][c], board[r][c]];
      }
    }
  }
  return false;
}

//Tile Shuffler
function shuffleBoard() {

  const flat = board.flat();
  for (let i = flat.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [flat[i], flat[j]] = [flat[j], flat[i]];
  }

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      board[r][c] = flat[r * COLS + c];
    }
  }

  renderWholeBoard();
}

function animateShuffleAndResolve() {
  const FADE_OUT_MS = 500; 
  const FADE_IN_MS  = 600; 
  const BUFFER_MS   = 20;  
 
  const tiles = Array.from(innerBoard.querySelectorAll('.tile'));

  if (tiles.length === 0) {
    shuffleBoard();
    
    setTimeout(() => resolveMatchesAndCascade(false), 50);
    return;
  }

  
  tiles.forEach(tile => {
    
    tile.classList.remove('matching','shake','selected','random-pop','scrambling','fading-in');
    tile.classList.add('fading-out');
  });

  setTimeout(() => {
  
    shuffleBoard();

    const newTiles = Array.from(innerBoard.querySelectorAll('.tile'));
    newTiles.forEach(t => {
      t.style.opacity = 0;
      void t.offsetWidth;
      t.classList.add('fading-in');
    });

    setTimeout(() => {
      newTiles.forEach(t => {
        t.classList.remove('fading-in');
        t.style.opacity = '';
      });
      resolveMatchesAndCascade(false);
    }, FADE_IN_MS + BUFFER_MS);

  }, FADE_OUT_MS + BUFFER_MS);
}


function showShuffleOverlay(duration = 1000) {
  const overlay = document.getElementById('shuffleOverlay');
  overlay.style.opacity = 1;

  setTimeout(() => {
    overlay.style.opacity = 0;
  }, duration);
}


const mechanicsBtn = document.getElementById("mechanicsBtn");
const mechanicsModal = new bootstrap.Modal(document.getElementById('mechanicsModal'));

mechanicsBtn.addEventListener("click", () => {
  mechanicsModal.show();
});


const ROWS = 8, COLS = 8;
const IMAGE_PREFIX = 'images/gcandy';
const BONUS_IMAGE = 'images/bonuscandy.png';

const bonusSound = new Audio("sounds/soundeffects/kwengkweng.MP3");
bonusSound.volume = 1; 

const matchSound = new Audio("sounds/soundeffects/sfx2.mp3");
matchSound.volume = 1; 

const hurryBonusSound = new Audio("sounds/soundeffects/sfx1.mp3");
hurryBonusSound.volume = 1; 

const invalidMatchSound = new Audio('sounds/soundeffects/sfx3.mp3');
const timeUpSound = new Audio('sounds/soundeffects/sfx4.mp3');
const noMovesLeftSound = new Audio('sounds/soundeffects/sfx4.mp3');
const swishSound = new Audio('sounds/soundeffects/4tilesfx.mp3');
swishSound.volume = 1; 
const TLSound = new Audio('sounds/soundeffects/TLtilesfx.MP3');
TLSound.volume = 1; 
const colorBombSound = new Audio('sounds/soundeffects/colorbomb.mp3');
colorBombSound.volume = 1;

let board = [], score = 0, firstSelection = null, dragSource = null;
let mode = null, movesLeft = 0, timerValue = 0;
let timerInterval = null, dizzyInterval = null;

const mainMenu = document.getElementById('mainMenu');
const gameContainer = document.getElementById('gameContainer');
const innerBoard = document.getElementById('innerBoard');
const scoreDisplay = document.getElementById('scoreDisplay');
const timerDisplay = document.getElementById('timerDisplay');

function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }
function randomCandyValue(){ return (mode === 'Swish and Match') ? randInt(1, 9) : randInt(1, 8); }
function createTileElement(r, c, val) {
  const tile = document.createElement('div');
  tile.className = 'tile';
  tile.dataset.r = r;
  tile.dataset.c = c;

  tile.draggable = true;

  const img = document.createElement('img');
  img.className = 'tileImg';
  img.src = (val === 9) ? BONUS_IMAGE : `${IMAGE_PREFIX}${val}.png`;
  tile.appendChild(img);


  let ghost = null;
  let touchData = null;

  tile.addEventListener('touchstart', function (e) {
    e.preventDefault();
    if (isResolving) return;
    const touch = e.changedTouches[0];
    const rect = tile.getBoundingClientRect();

    ghost = tile.cloneNode(true);
    ghost.style.position = "fixed";
    ghost.style.left = rect.left + "px";
    ghost.style.top = rect.top + "px";
    ghost.style.width = rect.width + "px";
    ghost.style.height = rect.height + "px";
    ghost.style.zIndex = 9999;
    ghost.style.opacity = 0.8;
    ghost.style.pointerEvents = "none";
    document.body.appendChild(ghost);

    touchData = {
      id: touch.identifier,
      offsetX: touch.clientX - rect.left,
      offsetY: touch.clientY - rect.top,
      r, c
    };
  }, { passive: false });

  tile.addEventListener('touchmove', function (e) {
    if (!touchData) return;
    const touch = [...e.changedTouches].find(t => t.identifier === touchData.id);
    if (!touch) return;

    ghost.style.left = (touch.clientX - touchData.offsetX) + "px";
    ghost.style.top = (touch.clientY - touchData.offsetY) + "px";
    e.preventDefault();
  }, { passive: false });

  function endTouch(e) {
    if (!touchData) return;
    const touch = [...e.changedTouches].find(t => t.identifier === touchData.id);
    if (!touch) return;

    if (ghost) ghost.remove();
    ghost = null;

    const elUnder = document.elementFromPoint(touch.clientX, touch.clientY);
    const targetTile = elUnder ? elUnder.closest('.tile') : null;

    if (targetTile && targetTile.dataset.r !== undefined) {
      const tr = parseInt(targetTile.dataset.r, 10);
      const tc = parseInt(targetTile.dataset.c, 10);
      const sr = touchData.r, sc = touchData.c;

      if (areAdjacent({ r: sr, c: sc }, { r: tr, c: tc })) {
        swapAndResolve({ r: sr, c: sc }, { r: tr, c: tc });
      }
    }

    touchData = null;
  }

  tile.addEventListener('touchend', endTouch, { passive: false });
  tile.addEventListener('touchcancel', endTouch, { passive: false });

 
  tile.addEventListener('dragstart', (e) => {
    dragSource = { r, c };
  });

  tile.addEventListener('dragover', (e) => {
    e.preventDefault(); 
  });

  tile.addEventListener('drop', (e) => {
    const tr = parseInt(tile.dataset.r, 10);
    const tc = parseInt(tile.dataset.c, 10);
    onTileDrop(tr, tc);
  });

 
  tile.addEventListener('click', () => onTileClick(r, c));

  return tile;
}



function spawnFloatingScore(r, c, points) {
  const tile = tileDomAt(r, c);
  if(!tile) return;

  const tileRect = tile.getBoundingClientRect();
  const boardRect = gameContainer.getBoundingClientRect();

  const scoreEl = document.createElement('div');
  scoreEl.className = 'floating-score';
  scoreEl.textContent = `+${points}`;

  
  scoreEl.style.position = 'absolute';
  scoreEl.style.left = `${tileRect.left - boardRect.left + tileRect.width/2 - 12}px`;
  scoreEl.style.top = `${tileRect.top - boardRect.top}px`;

  gameContainer.appendChild(scoreEl);

  setTimeout(() => {
    if(scoreEl.parentElement) scoreEl.parentElement.removeChild(scoreEl);
  }, 800); // animation duration
}

function createBoardInitial(){
  board = [];
  for(let r=0; r<ROWS; r++){
    const row = [];
    for(let c=0; c<COLS; c++) row.push(randomCandyValue());
    board.push(row);
  }
  renderWholeBoard();
  setTimeout(() => resolveMatchesAndCascade(true), 50);
}

function renderWholeBoard(){
  innerBoard.innerHTML = '';
  for(let r=0; r<ROWS; r++){
    for(let c=0; c<COLS; c++){
      innerBoard.appendChild(createTileElement(r, c, board[r][c]));
    }
  }
}

function tileDomAt(r,c){ return innerBoard.querySelector(`.tile[data-r="${r}"][data-c="${c}"]`); }
function areAdjacent(a,b){ return Math.abs(a.r-b.r)+Math.abs(a.c-b.c)===1; }


function updateHUD(){
  const modeDisplay = document.getElementById('modeDisplay');
  scoreDisplay.textContent = `Score: ${score}`;
  if(modeDisplay){
    modeDisplay.textContent = `${mode}`; // show current mode
  }
  	if(mode === 'Hurry Hurry'){
		const minutes = Math.floor(timerValue / 60);
		const seconds = timerValue % 60;
		timerDisplay.textContent = `Time: ${minutes}:${seconds.toString().padStart(2,'0')}`;
		
		if(timerValue <= 10){
			timerDisplay.classList.add('time-warning'); // pulse + glow
		} else {
			timerDisplay.classList.remove('time-warning');
		}
	}
  else if(mode==='Swish and Match') timerDisplay.textContent = `Moves: ${movesLeft}`;
  else {
    timerDisplay.textContent = 'Time: ‚àû';
  }
}

let hurryTimerStarted = false;

function startTimer() {
  clearInterval(timerInterval);

  if (mode === 'Hurry Hurry') {
    timerValue = 120; // 2 minutes in seconds
    updateHUD();
  } else {
    timerValue = 999;
    updateHUD();
  }

  timerInterval = setInterval(() => {
    if (mode === 'Hurry Hurry' && !isPaused) { // üëà stop counting when paused
      timerValue--;
      updateHUD();

      if (timerValue <= 0) {
        timeUpSound.currentTime = 0;
        timeUpSound.play();
        clearInterval(timerInterval);
        setTimeout(() => gameOver('Time is up!'), 500);
      }
    }
  }, 1000); // 1000ms = 1 second
}

let isResolving = false;
function awaitAnimationEnd(el, expectedName = null) {
  return new Promise((resolve) => {
    if (!el) return resolve();
    function onEnd(e) {
      
      if (expectedName && e.animationName !== expectedName) return;
      el.removeEventListener('animationend', onEnd);
      resolve(e);
    }
    el.addEventListener('animationend', onEnd);

    setTimeout(() => {
      try { el.removeEventListener('animationend', onEnd); } catch(e) {}
      resolve();
    }, 900); 
  });
}

function updateTileAt(r, c) {
  const tile = tileDomAt(r, c);
  if (!tile) return;
  const val = board[r][c];
  const img = tile.querySelector("img");
  if (img) img.src = (val === 9) ? BONUS_IMAGE : `${IMAGE_PREFIX}${val}.png`;
}

function onTileClick(r, c){
  if (isResolving) return; 
  const clickedTile = tileDomAt(r, c);

  if(firstSelection){
    if(firstSelection.r===r && firstSelection.c===c){
      firstSelection=null;
      clickedTile.classList.remove('selected');
      return;
    }

    if(areAdjacent(firstSelection,{r,c})){
      swapAndResolve(firstSelection,{r,c});
  
	const valA = board[firstSelection.r][firstSelection.c];
	const valB = board[r][c];
	const isBonusSwap = (valA === 9 || valB === 9);
      updateHUD();

 
      tileDomAt(firstSelection.r, firstSelection.c)?.classList.remove('selected');
      clickedTile.classList.remove('selected');
    }else {

      const tileA = tileDomAt(firstSelection.r, firstSelection.c);
      const tileB = tileDomAt(r, c);
      tileA?.classList.add('shake');
      tileB?.classList.add('shake');
      setTimeout(() => {
        tileA?.classList.remove('shake');
        tileB?.classList.remove('shake');
      }, 250);
    }	
    firstSelection=null;
  } else {
    firstSelection={r,c};
    clickedTile.classList.add('selected'); // keep glow when selected
  }
}

function onTileDrop(r, c) {
  if (isResolving) return;
  if (dragSource) {
    if (areAdjacent(dragSource, { r, c })) {
      swapAndResolve(dragSource, { r, c });
	  const valA = board[dragSource.r][dragSource.c];
	  const valB = board[r][c];
	  const isBonusSwap = (valA === 9 || valB === 9);
      updateHUD();
    } else {
      const tileA = tileDomAt(dragSource.r, dragSource.c);
      const tileB = tileDomAt(r, c);
      tileA?.classList.add('shake');
      tileB?.classList.add('shake');
      setTimeout(() => {
        tileA?.classList.remove('shake');
        tileB?.classList.remove('shake');
      }, 250);
    }
  }
  dragSource = null;
}

async function swapAndResolve(a, b) {
  if (isResolving) return;
  isResolving = true;
  
  resetAttemptIdleTimer();
  
  // swap in memory, update the two tiles visually
  [board[a.r][a.c], board[b.r][b.c]] = [board[b.r][b.c], board[a.r][a.c]];
  updateTileAt(a.r, a.c);
  updateTileAt(b.r, b.c);

  const matches = findAllMatches();
  if (matches.length === 0) {
    // invalid swap: brief delay so user sees swap, then revert + shake
    await new Promise(r => setTimeout(r, 160));
    invalidMatchSound.currentTime = 0;
    invalidMatchSound.play();

    // revert in memory and update visuals
    [board[a.r][a.c], board[b.r][b.c]] = [board[b.r][b.c], board[a.r][a.c]];
    updateTileAt(a.r, a.c);
    updateTileAt(b.r, b.c);

    const tileA = tileDomAt(a.r, a.c);
    const tileB = tileDomAt(b.r, b.c);
    tileA?.classList.add('shake');
    tileB?.classList.add('shake');

    // wait for shake animation to finish (fallback timeout)
    await Promise.all([
      awaitAnimationEnd(tileA, 'shake').catch(()=>{}),
      awaitAnimationEnd(tileB, 'shake').catch(()=>{})
    ]);

    tileA?.classList.remove('shake');
    tileB?.classList.remove('shake');

    isResolving = false;
  } else {
    // there are matches => resolve normally (pass true: player move)
    await resolveMatchesAndCascade(true, true);
    // resolveMatchesAndCascade will unlock isResolving after done
  }
}

let hintTimer;

function resetHintTimer() {
  clearTimeout(hintTimer);
  hintTimer = setTimeout(() => {
    showHint();  // only trigger if no matches found after some time
  }, 8000); // 8s without a valid match
}

function showHint() {
  // Remove old hints first
  document.querySelectorAll('.tile.hint').forEach(t => t.classList.remove('hint'));

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      // Try right swap
      if (c < COLS - 1) {
        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
        if (findAllMatches().length > 0) {
          [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
          tileDomAt(r, c)?.classList.add('hint');
          tileDomAt(r, c+1)?.classList.add('hint');
          return;
        }
        [board[r][c], board[r][c+1]] = [board[r][c+1], board[r][c]];
      }

      // Try down swap
      if (r < ROWS - 1) {
        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
        if (findAllMatches().length > 0) {
          [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
          tileDomAt(r, c)?.classList.add('hint');
          tileDomAt(r+1, c)?.classList.add('hint');
          return;
        }
        [board[r][c], board[r+1][c]] = [board[r+1][c], board[r][c]];
      }
    }
  }
}

function findAllMatches() {
  const matched = [];

  //  Horizontal checks
  for (let r = 0; r < ROWS; r++) {
    let runVal = board[r][0], runCount = 1;
    for (let c = 1; c < COLS; c++) {
      if (board[r][c] === runVal) {
        runCount++;
      } else {
        if (runCount >= 3) {
          if (runCount === 5) {
            //  Found Color Bomb (5 in a row)
            matched.push({
              r,
              c: c - 3,   // roughly center tile
              type: "colorbomb",
              val: runVal
            });
          } else {
            // Normal / Row4
            for (let k = 0; k < runCount; k++) {
              matched.push({
                r,
                c: c - 1 - k,
                type: runCount === 4 ? "row4" : "normal",
                val: runVal
              });
            }
          }
        }
        runVal = board[r][c];
        runCount = 1;
      }
    }

    if (runCount >= 3) {
      if (runCount === 5) {
        matched.push({
          r,
          c: COLS - 3,
          type: "colorbomb",
          val: runVal
        });
      } else {
        for (let k = 0; k < runCount; k++) {
          matched.push({
            r,
            c: COLS - 1 - k,
            type: runCount === 4 ? "row4" : "normal",
            val: runVal
          });
        }
      }
    }
  }

  //  Vertical checks
  for (let c = 0; c < COLS; c++) {
    let runVal = board[0][c], runCount = 1;
    for (let r = 1; r < ROWS; r++) {
      if (board[r][c] === runVal) {
        runCount++;
      } else {
        if (runCount >= 3) {
          if (runCount === 5) {
            matched.push({
              r: r - 3,
              c,
              type: "colorbomb",
              val: runVal
            });
          } else {
            for (let k = 0; k < runCount; k++) {
              matched.push({
                r: r - 1 - k,
                c,
                type: runCount === 4 ? "col4" : "normal",
                val: runVal
              });
            }
          }
        }
        runVal = board[r][c];
        runCount = 1;
      }
    }

    if (runCount >= 3) {
      if (runCount === 5) {
        matched.push({
          r: ROWS - 3,
          c,
          type: "colorbomb",
          val: runVal
        });
      } else {
        for (let k = 0; k < runCount; k++) {
          matched.push({
            r: ROWS - 1 - k,
            c,
            type: runCount === 4 ? "col4" : "normal",
            val: runVal
          });
        }
      }
    }
  }

  //  Deduplicate & merge types (your same logic)
  const seen = new Map(), unique = [];
  for (const m of matched) {
    const key = `${m.r},${m.c}`;
    if (!seen.has(key)) {
      seen.set(key, { ...m });
      unique.push(seen.get(key));
    } else {
      const existing = seen.get(key);
      if (existing.type !== m.type) {
        if (!existing.type.includes(m.type)) {
          existing.type += "+" + m.type;
        }
      }
    }
  }

  //  L/T shape detection
  const wrapped = detectLTShapes(unique);
  wrapped.forEach(w => {
    const key = `${w.r},${w.c}`;
    if (seen.has(key)) {
      seen.get(key).type = "wrapped";
    } else {
      seen.set(key, w);
      unique.push(w);
    }
  });

  return unique;
}

function detectLTShapes(unique) {
  const wrapped = [];

  for (const m of unique) {
    let hRun = unique.filter(t => t.r === m.r && t.val === m.val);
    let vRun = unique.filter(t => t.c === m.c && t.val === m.val);

    if (hRun.length >= 3 && vRun.length >= 3) {
      wrapped.push({ r: m.r, c: m.c, type: "wrapped", val: m.val });
    }
  }

  return wrapped;
}

function spawnFloatingMove(r, c, amount = 1) {
  try {
    const tile = tileDomAt(r, c);
    if (!tile) return; // nothing to attach to

    const gameRect = gameContainer.getBoundingClientRect();
    const tileRect = tile.getBoundingClientRect();

    const el = document.createElement('div');
    el.className = 'floating-move';
    el.textContent = `+${amount} Move${amount > 1 ? 's' : ''}`;

    // position relative to gameContainer
    el.style.position = 'absolute';
    el.style.left = `${tileRect.left - gameRect.left + tileRect.width / 2}px`;
    el.style.top = `${tileRect.top - gameRect.top}px`;
    el.style.pointerEvents = 'none';
    el.style.zIndex = 9999;

    gameContainer.appendChild(el);

    // remove after animation
    setTimeout(() => {
      try { el.remove(); } catch (e) {}
    }, 1000);
  } catch (err) {
    console.error('spawnFloatingMove error', err);
  }
}
try { spawnFloatingMove(m.r, m.c); } catch(e){ console.error(e); }

async function resolveMatchesAndCascade(initialFlag, isPlayerMove = false) {
  if (isResolving === false) isResolving = true;

  let matches = findAllMatches();
  if (matches.length === 0) {
    isResolving = false;
    return;
  }
  resetHintTimer();

  // üîπ Handle clears (mark tiles null + play animations)
  for (const m of matches) {
    if (m.type.includes("row4")) {
      swishSound.currentTime = 0;
      swishSound.play();

      for (let cc = 0; cc < COLS; cc++) {
        const t = tileDomAt(m.r, cc);
        if (t) t.classList.add("row-clearing");

        if (board[m.r][cc] != null) {
          if (mode === 'Swish and Match' && board[m.r][cc] === 9) {
            movesLeft++;
            bonusSound.currentTime = 0;
            bonusSound.play();
            spawnFloatingMove(m.r, cc);
          } else {
            score += 15;
            spawnFloatingScore(m.r, cc, 15);
          }
          board[m.r][cc] = null;
        }
      }
    }

    if (m.type.includes("col4")) {
      swishSound.currentTime = 0;
      swishSound.play();

      for (let rr = 0; rr < ROWS; rr++) {
        const t = tileDomAt(rr, m.c);
        if (t) t.classList.add("col-clearing");

        if (board[rr][m.c] != null) {
          if (mode === 'Swish and Match' && board[rr][m.c] === 9) {
            movesLeft++;
            bonusSound.currentTime = 0;
            bonusSound.play();
            spawnFloatingMove(rr, m.c);
          } else {
            score += 15;
            spawnFloatingScore(rr, m.c, 15);
          }
          board[rr][m.c] = null;
        }
      }
    }

    if (m.type === "wrapped") {
      swishSound.currentTime = 0;
      swishSound.play();
      for (let rr = m.r - 1; rr <= m.r + 1; rr++) {
        for (let cc = m.c - 1; cc <= m.c + 1; cc++) {
          if (rr >= 0 && rr < ROWS && cc >= 0 && cc < COLS) {
            if (board[rr][cc] !== null) {
              if (mode === 'Swish and Match' && board[rr][cc] === 9) {
                movesLeft++;
                bonusSound.currentTime = 0;
                bonusSound.play();
                spawnFloatingMove(rr, cc);
              } else {
                score += 15;
                spawnFloatingScore(rr, cc, 15);
              }

              board[rr][cc] = null;

              const t = tileDomAt(rr, cc);
              if (t) t.classList.add("wrapped-clearing");
            }
          }
        }
      }
    }

    if (m.type === "colorbomb") {
      const targetColor = m.val;  
      if (!targetColor) continue;

      colorBombSound.currentTime = 0;
      colorBombSound.play();

      // Every candy of this color acts like a striped clear
      for (let rr = 0; rr < ROWS; rr++) {
        for (let cc = 0; cc < COLS; cc++) {
          if (board[rr][cc] === targetColor) {
            if (Math.random() < 0.5) {
              // Row clear
              swishSound.currentTime = 0;
              swishSound.play();

              const triggerTile = tileDomAt(rr, cc);
              if (triggerTile) triggerTile.classList.add("row-clearing");

              for (let x = 0; x < COLS; x++) {
                const t = tileDomAt(rr, x);
                if (t) t.classList.add("matching");
                if (board[rr][x] != null) {
                  if (mode === 'Swish and Match' && board[rr][x] === 9) {
                    movesLeft++;
                    bonusSound.currentTime = 0;
                    bonusSound.play();
                    spawnFloatingMove(rr, x);
                  } else {
                    score += 20;
                    spawnFloatingScore(rr, x, 20);
                  }
                  board[rr][x] = null;
                }
              }
            } else {
              // Column clear
              swishSound.currentTime = 0;
              swishSound.play();

              const triggerTile = tileDomAt(rr, cc);
              if (triggerTile) triggerTile.classList.add("col-clearing");

              for (let y = 0; y < ROWS; y++) {
                const t = tileDomAt(y, cc);
                if (t) t.classList.add("matching");
                if (board[y][cc] != null) {
                  if (mode === 'Swish and Match' && board[y][cc] === 9) {
                    movesLeft++;
                    bonusSound.currentTime = 0;
                    bonusSound.play();
                    spawnFloatingMove(y, cc);
                  } else {
                    score += 10;
                    spawnFloatingScore(y, cc, 10);
                  }
                  board[y][cc] = null;
                }
              }
            }
          }
        }
      }
    }

    if (m.type === "normal") {
      const t = tileDomAt(m.r, m.c);
      if (t) t.classList.add("matching");

      if (board[m.r][m.c] != null) {
        if (mode === 'Swish and Match' && board[m.r][m.c] === 9) {
          movesLeft++;
          bonusSound.currentTime = 0;
          bonusSound.play();
          spawnFloatingMove(m.r, m.c);
        } else {
          score += 10;
          spawnFloatingScore(m.r, m.c, 10);
        }
        board[m.r][m.c] = null;
      }
    }
  }

  // üîπ Start cascade immediately (don‚Äôt wait for pop animations)
  collapseAndRefill();

  // Meanwhile, let pop animations finish
  const tiles = [];
  matches.forEach(pos => {
    const t = tileDomAt(pos.r, pos.c);
    if (t) {
      t.dataset.busy = 'true';
      tiles.push({ el: t, pos });
    }
  });

  await Promise.all(tiles.map(t => awaitAnimationEnd(t.el, 'matchPop').catch(() => {})));

  // Hurry Hurry bonus logic
  let suppressMatchSound = false;
  if (mode === 'Hurry Hurry') {
    const scoreBonus = Math.floor(score / 150) * 10;
    const previousBonus = Math.floor((score - matches.length * 10) / 150) * 10;
    const addedTime = scoreBonus - previousBonus;
    if (addedTime > 0) {
      timerValue += addedTime;
      hurryBonusSound.currentTime = 0;
      hurryBonusSound.play();
      suppressMatchSound = true;
    }
  }

  const onlyNormalMatches = matches.every(m => m.type === "normal");

  if (matches.length > 0 && !suppressMatchSound && onlyNormalMatches) {
    matchSound.currentTime = 0;
    matchSound.play();
  }

  // Swish & Move mode
  if (mode === 'Swish and Match') {
    if (isPlayerMove) {
      const matchedBonus = matches.some(m => m.val === 9);
      if (!matchedBonus) {
        movesLeft--;
      }
    }
    updateHUD();
    if (movesLeft <= 0) {
      noMovesLeftSound.currentTime = 0;
      noMovesLeftSound.play();
      setTimeout(() => gameOver('No Move Left!'), 500);
    }
  } else {
    updateHUD();
  }

  // üîπ Short wait so cascade animations can show
  await new Promise(r => setTimeout(r, 140));

  // Recursively resolve
  await resolveMatchesAndCascade(false, false);

  if (!hasPossibleMoves()) {
    showShuffleOverlay(1200);
    setTimeout(() => animateShuffleAndResolve(), 1300);
  }

  // Cleanup animations
  const allTiles = Array.from(innerBoard.querySelectorAll('.tile'));
  allTiles.forEach(t => {
    if (t.dataset.busy) delete t.dataset.busy;
    t.classList.remove('matching', 'row-clearing', 'col-clearing', 'wrapped-clearing');
  });

  isResolving = false;
}

//Cascade Helper

function recordScore() {
  if (playerName && score > 0) {
    submitScore(playerName, score, mode);
  }
}

function gameOver(reason) {
  clearInterval(timerInterval);
  clearInterval(dizzyInterval);
  
  alert(`Game Over! ${reason}\n Your total score: ${score}`);
  recordScore();
  
  showMenu();
  
}

function activateColorBomb(r, c, targetVal) {
  if (!targetVal) return;

  colorBombSound.currentTime = 0;
  colorBombSound.play();

  // Every candy of this color acts like a striped clear
  for (let rr = 0; rr < ROWS; rr++) {
    for (let cc = 0; cc < COLS; cc++) {
      if (board[rr][cc] === targetVal) {
        if (Math.random() < 0.5) {
          //  Row clear
          swishSound.currentTime = 0;
          swishSound.play();

          const triggerTile = tileDomAt(rr, cc);
          if (triggerTile) triggerTile.classList.add("row-clearing");

          for (let x = 0; x < COLS; x++) {
            const t = tileDomAt(rr, x);
            if (t) t.classList.add("matching");
            if (board[rr][x] != null) {
              board[rr][x] = null;
              score += 10;
              spawnFloatingScore(rr, x, 10);
            }
          }
        } else {
          //  Column clear
          swishSound.currentTime = 0;
          swishSound.play();

          const triggerTile = tileDomAt(rr, cc);
          if (triggerTile) triggerTile.classList.add("col-clearing");

          for (let y = 0; y < ROWS; y++) {
            const t = tileDomAt(y, cc);
            if (t) t.classList.add("matching");
            if (board[y][cc] != null) {
              board[y][cc] = null;
              score += 10;
              spawnFloatingScore(y, cc, 10);
            }
          }
        }
      }
    }
  }

  // Collapse board after a short delay
  setTimeout(() => collapseAndRefill(), 300);
}


function collapseAndRefill() {
  const missingPerCol = Array(COLS).fill(0);
  const movedTiles = [];

  for (let c = 0; c < COLS; c++) {
    const stack = [];
    for (let r = ROWS - 1; r >= 0; r--) {
      if (board[r][c] != null) {
        stack.push(board[r][c]);
      }
    }

    // Count missing
    const missing = ROWS - stack.length;
    missingPerCol[c] = missing;

    // Add new random candies
    for (let i = 0; i < missing; i++) {
      stack.push(randomCandyValue());
    }

    // Place back into board
    for (let r = ROWS - 1, i = 0; r >= 0; r--, i++) {
      const oldVal = board[r][c];
      const newVal = stack[i];
      if (oldVal !== newVal && oldVal != null) {
        movedTiles.push({ r, c });
      }
      board[r][c] = newVal;
    }
  }

  // Redraw everything
  renderWholeBoard();

  // Animate new spawns
  for (let c = 0; c < COLS; c++) {
    for (let r = 0; r < missingPerCol[c]; r++) {
      const t = tileDomAt(r, c);
      if (!t) continue;
      t.classList.add("spawning");
      t.addEventListener("animationend", () => {
        t.classList.remove("spawning");
      }, { once: true });
    }
  }

  // Animate falling with stagger
for (const tile of movedTiles) {
  const t = tileDomAt(tile.r, tile.c);
  if (!t) continue;

  // reset animation
  t.classList.remove("falling");
  t.style.animation = "none";
  void t.offsetWidth;
  t.style.animation = "";

  // compute how far this tile actually fell
  const fallDistance = (missingPerCol[tile.c] * 50) + "%";
  t.style.setProperty("--fall-distance", fallDistance);

  // add falling with stagger
  t.classList.add("falling");
  t.style.animationDelay = `${(ROWS - tile.r) * 0.00}s`;

  t.addEventListener("animationend", () => {
    t.classList.remove("falling");
    t.style.animationDelay = "";
    t.style.removeProperty("--fall-distance");
  }, { once: true });
}}

function startDizzy() {
  console.log("üé≤ Dizzy spawner started");
  clearInterval(dizzyInterval); // prevent stacking

  dizzyInterval = setInterval(async () => {
    // üîπ Skip spawning if paused or modal visible
    if (isPaused || !pauseModal.classList.contains("hidden")) {
      return;
    }

    let anyChange = false;
    const changePromises = [];

    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (Math.random() < 0.08) {
          const t = tileDomAt(r, c);
          if (!t) continue;

          // skip if tile is busy (matching, shaking, etc.)
          if (
            t.dataset.busy === "true" ||
            t.classList.contains("shake") ||
            t.classList.contains("matching")
          ) {
            continue;
          }

          anyChange = true;
          t.dataset.busy = "true";
          t.classList.add("dizzyChange");

          (function (rr, cc, tileEl) {
            const p = (async () => {
              await awaitAnimationEnd(tileEl, "dizzyPop").catch(() => {});
              const newVal = randomCandyValue();
              board[rr][cc] = newVal;
              updateTileAt(rr, cc);

              tileEl.classList.remove("dizzyChange");
              tileEl.classList.add("fading-in");

              await awaitAnimationEnd(tileEl, "fadeInGlow").catch(() => {});
              setTimeout(() => {
                tileEl.classList.remove("fading-in");
              }, 600);

              delete tileEl.dataset.busy;
            })();
            changePromises.push(p);
          })(r, c, t);
        }
      }
    }

    if (anyChange) {
      try {
        await Promise.all(changePromises);
      } catch (e) {}
      await new Promise((r) => setTimeout(r, 80));
      await resolveMatchesAndCascade(false, false);
    }
  }, 2000);
}

function showMenu(){
  stopMusic();
  mainMenu.style.display='flex';
  gameContainer.style.display='none';
  musicPlayerBox.style.display='none';
  
  clearInterval(timerInterval);
  clearInterval(dizzyInterval);
  
  gameActive = false;
  hidePauseModal();  // just in case modal was open
  clearTimeout(attemptIdleTimer);
  
  const timerDisplay = document.getElementById('timerDisplay');
  if (timerDisplay) {
    timerDisplay.classList.remove('time-warning');
    timerDisplay.textContent = ''; // optional: clear timer text
  }
  
  menuMusic.currentTime = 0;
  menuMusic.play().catch(e => console.log("Autoplay blocked:", e));
  gameTitle.classList.add("animate");

    // Optional: remove class after animation ends so it won‚Äôt repeat
    setTimeout(() => {
      gameTitle.classList.remove("animate");
    }, 1500);
}


function startGame(selectedMode){
  
  menuMusic.pause();
  menuMusic.currentTime = 0;
  
  startMusic();
  
  mode = selectedMode;
  score = 0; movesLeft = 20; firstSelection=null;
  
  mainMenu.style.display='none';
  gameContainer.style.display='flex';
  musicPlayerBox.style.display='flex';
  gameActive = true;
  gameLoop();
  resetAttemptIdleTimer();
    
  createBoardInitial();
  updateHUD();
  
  if(mode==='Hurry Hurry') startTimer();
  else if(mode==='Dizzy Dizzy') startDizzy();
}

document.getElementById('classicBtn').onclick = ()=>startGame('Classic');
document.getElementById('hurryBtn').onclick = ()=>startGame('Hurry Hurry');
document.getElementById('dizzyBtn').onclick = ()=>startGame('Dizzy Dizzy');
document.getElementById('swishBtn').onclick = ()=>startGame('Swish and Match');
document.getElementById('backButton').onclick = () => {submitScore(playerName, score, mode); showMenu(); };


const menuMusic = new Audio('sounds/Moshi Moshi JP ver-instrumental.mp3'); 
menuMusic.loop = true; // loop while on menu
menuMusic.volume = 0.5; // adjust volume


const songs = [
  { title: "Any Angle(ÏõêÍ≥° : ‰πÉÁ¥´)", file: "https://www.youtube.com/watch?v=DSB5g073z9Y ", type: "youtube" },
  { title: "Butterfly's Dream", file: "https://www.youtube.com/watch?v=Pd--ARdOC_c", type: "youtube" },
  { title: "Curious", file: "https://www.youtube.com/watch?v=V3Xpaadt-RA", type: "youtube" },
  { title: "Dating Myself", file: "https://www.youtube.com/watch?v=zAb7_f45Zh8", type: "youtube" },
  { title: "DDANG!", file: "https://www.youtube.com/watch?v=eNEfyLw3WfQ&pp=ygUKdW5pcyBkZGFuZw%3D%3D", type: "youtube" },
  { title: "Dopamine", file: "https://www.youtube.com/watch?v=7xHZpIxtSZ4", type: "youtube" },
  { title: "Dream of Girls", file: "https://www.youtube.com/watch?v=4W0Qx8gZWKk", type: "youtube" },
  { title: "From The Seed Called Hey Whats Up", file: "https://www.youtube.com/watch?v=vEmwBHJugkY", type: "youtube" },
  { title: "Good Feeling", file: "sounds/Good Feeling.mp3", type: "local" },
  { title: "Love, Day After Tomorrow", file: "https://www.youtube.com/watch?v=uEYKrHztkKE", type: "youtube" },
  { title: "Moshi Moshi EN ver.", file: "https://www.youtube.com/watch?v=RvZEOq5MGzY", type: "youtube" },
  { title: "Moshi Moshi JP ver.", file: "https://www.youtube.com/watch?v=DrU5bxPcH0s", type: "youtube" },
  { title: "Poppin", file: "https://www.youtube.com/watch?v=iezL1ao7s8k", type: "youtube" },
  { title: "See you in my dream (ÍøàÏóêÏÑú Îòê ÎßåÎÇò)", file: "https://www.youtube.com/watch?v=MOudTwsEXzU", type: "youtube" },
  { title: "Shaking My Head", file: "https://www.youtube.com/watch?v=hGNdSFlWUvA", type: "youtube" },
  { title: "Spring Rain", file: "https://www.youtube.com/watch?v=LRMRr22T7UQ&pp=ygUQdW5pcyBzcHJpbmcgcmFpbg%3D%3D", type: "youtube" },
  { title: "Superwoman", file: "sounds/Superwoman.mp3", type: "local" },
  { title: "Swicy", file: "sounds/Swicy.mp3", type: "local" },
  { title: "Watchu Need", file: "https://www.youtube.com/watch?v=aE2sk_LbR78", type: "youtube" }  
];


let currentSongIndex = 0;
let isPlaying = false;
const video = document.getElementById("videoPlayer");
const audio = document.getElementById("audioPlayer");
const playBtn = document.getElementById("playBtn");
const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");
const progressBar = document.getElementById("progressBar");
const songTitle = document.getElementById("songTitle");
const songList = document.getElementById("songList");

const youtubeContainer = document.getElementById("youtubePlayerContainer");
const youtubeIframe = document.getElementById("youtubePlayer");

const playerWrapper = document.getElementById("playerWrapper");

let youtubePlayer;

function onYouTubeIframeAPIReady() {
  youtubePlayer = new YT.Player("youtubePlayer", {
    height: "100%",
    width: "100%",
    videoId: "",  // will be set dynamically
    playerVars: {
      rel: 0,
      modestbranding: 1,
      controls: 1   // set to 0 if you want only your custom buttons
    },
    events: {
    onReady: () => console.log("YouTube Player Ready"),
	onStateChange: (event) => {
	  if (event.data === YT.PlayerState.ENDED) {
		stopYouTubeProgress();
		nextSong();
	  } else if (event.data === YT.PlayerState.PLAYING) {
		isPlaying = true;
		playBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
		startYouTubeProgress();
	  } else if (event.data === YT.PlayerState.PAUSED) {
		isPlaying = false;
		playBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
		stopYouTubeProgress();
	  }
	}

}
  });
}
function loadSong(index, autoplay = false) {
  currentSongIndex = index;
  const song = songs[index];
  songTitle.textContent = song.title;

  // Hide everything first
  audio.style.display = "none";
  video.style.display = "none";
  youtubePlayerContainer.style.display = "none"; // üîπ hide by default

if (song.type === "local") {
  // stop YT
  playerWrapper.style.display = "none";
  document.getElementById("musicPlayerBox").style.width = "100%";
  if (youtubePlayer && youtubePlayer.stopVideo) {
    youtubePlayer.stopVideo();
  }

  youtubePlayerContainer.style.display = "none";
  video.style.display = "none";
  audio.style.display = "block";
  audio.src = song.file;
  if (autoplay) audio.play();

} else if (song.type === "video") {
  // stop YT
  playerWrapper.style.display = "flex";
  if (youtubePlayer && youtubePlayer.stopVideo) {
    youtubePlayer.stopVideo();
  }

  youtubePlayerContainer.style.display = "none";
  audio.style.display = "none";
  video.style.display = "block";
  video.src = song.file;
  if (autoplay) video.play();

} else if (song.type === "youtube") {
  // pause audio/video
  playerWrapper.style.display = "flex";
  audio.pause();
  video.pause();

  youtubePlayerContainer.style.display = "block";

  const videoIdMatch = song.file.match(/(?:v=|\/)([0-9A-Za-z_-]{11})/);
  const videoId = videoIdMatch ? videoIdMatch[1] : null;

  if (autoplay) {
    youtubePlayer.loadVideoById(videoId);
  } else {
    youtubePlayer.cueVideoById(videoId);
  }
}

  isPlaying = autoplay;
  playBtn.innerHTML = autoplay
    ? '<i class="bi bi-pause-fill"></i>'
    : '<i class="bi bi-play-fill"></i>';
}



function playSong() {
  const song = songs[currentSongIndex];
  if (song.type === "local") {
    audio.play();
  } else if (song.type === "video") {
    video.play();
  } else if (song.type === "youtube") {
    youtubePlayer.playVideo();
  }
  isPlaying = true;
  playBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
}

function pauseSong() {
  const song = songs[currentSongIndex];
  if (song.type === "local") {
    audio.pause();
  } else if (song.type === "video") {
    video.pause();
  } else if (song.type === "youtube") {
    youtubePlayer.pauseVideo();
  }
  isPlaying = false;
  playBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
}

function nextSong(){
  let nextIndex = (currentSongIndex + 1) % songs.length;
  loadSong(nextIndex, true);
}

function prevSong(){
  let prevIndex = (currentSongIndex - 1 + songs.length) % songs.length;
  loadSong(prevIndex, true);
}

// Controls
playBtn.onclick = () => isPlaying ? pauseSong() : playSong();
nextBtn.onclick = nextSong;
prevBtn.onclick = prevSong;

// Volume
const volumeSlider = document.getElementById("volumeSlider");

// initialize volumes
audio.volume = volumeSlider.value / 100;
video.volume = volumeSlider.value / 100;

volumeSlider.addEventListener("input", e => {
  const vol = e.target.value / 100;

  // MP3
  audio.volume = vol;

  // MP4/WebM
  video.volume = vol;

  // YouTube
  if (youtubePlayer) {
    youtubePlayer.setVolume(vol * 100); // YT expects 0‚Äì100
  }
});

audio.addEventListener("timeupdate", () => {
  if(audio.duration) {
    const progress = (audio.currentTime / audio.duration) * 100;
    progressBar.style.width = `${progress}%`;
  }
});

audio.addEventListener("ended", nextSong);

// build dropup list
songs.forEach((s, idx) => {
  const li = document.createElement("li");
  const btn = document.createElement("button");
  btn.className = "dropdown-item";
  btn.textContent = s.title;
  btn.onclick = () => loadSong(idx, true);
  li.appendChild(btn);
  songList.appendChild(li);
});

// random autoplay when "game starts"
function startMusic() {
  const randomIndex = Math.floor(Math.random() * songs.length);
  loadSong(randomIndex, true);
}

// stop music when "back" clicked
function stopMusic() {
  // stop all
  audio.pause();
  video.pause();
  if (youtubePlayer && youtubePlayer.stopVideo) {
    youtubePlayer.stopVideo();
  }

  audio.currentTime = 0;
  video.currentTime = 0;

  isPlaying = false;
  progressBar.style.width = "0%";
  playBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
}

let ytProgressInterval = null;

function startYouTubeProgress() {
  clearInterval(ytProgressInterval);
  ytProgressInterval = setInterval(() => {
    if (youtubePlayer && youtubePlayer.getDuration) {
      const duration = youtubePlayer.getDuration();
      const currentTime = youtubePlayer.getCurrentTime();
      if (duration > 0) {
        const progress = (currentTime / duration) * 100;
        progressBar.style.width = `${progress}%`;
      }
    }
  }, 500); // update every 0.5s
}

const progressContainer = document.querySelector(".progress");

progressContainer.addEventListener("click", (e) => {
  const rect = progressContainer.getBoundingClientRect();
  const clickX = e.clientX - rect.left;
  const percentage = clickX / rect.width;

  const song = songs[currentSongIndex];

  if (song.type === "local" && audio.duration) {
    // Seek MP3
    audio.currentTime = audio.duration * percentage;
  } else if (song.type === "youtube" && youtubePlayer && youtubePlayer.getDuration) {
    // Seek YouTube
    const newTime = youtubePlayer.getDuration() * percentage;
    youtubePlayer.seekTo(newTime, true);
  }
});

let isScrubbing = false;

progressContainer.addEventListener("mousedown", (e) => {
  isScrubbing = true;
  seek(e); // jump immediately when click
});

document.addEventListener("mousemove", (e) => {
  if (isScrubbing) {
    seek(e);
  }
});

document.addEventListener("mouseup", () => {
  if (isScrubbing) {
    isScrubbing = false;
  }
});

function seek(e) {
  const rect = progressContainer.getBoundingClientRect();
  const clickX = Math.min(Math.max(e.clientX - rect.left, 0), rect.width);
  const percentage = clickX / rect.width;

  const song = songs[currentSongIndex];

  if (song.type === "local" && audio.duration) {
    audio.currentTime = audio.duration * percentage;
  } else if (song.type === "youtube" && youtubePlayer && youtubePlayer.getDuration) {
    const newTime = youtubePlayer.getDuration() * percentage;
    youtubePlayer.seekTo(newTime, true);
  }

  // Update UI immediately while dragging
  progressBar.style.width = `${percentage * 100}%`;
}

function stopYouTubeProgress() {
  clearInterval(ytProgressInterval);
  ytProgressInterval = null;
}

async function submitScore(name, score, mode) {
  const { data, error } = await supabase
    .from('leaderboard')
    .insert([{ name, score, mode, date: new Date() }]);

  if (error) {
    console.error("‚ùå Error submitting score:", error);
  } else {
    console.log("‚úÖ Score submitted:", data);
    // Refresh the leaderboard for this mode
    renderLeaderboard(mode, `leaderboard-${mode.toLowerCase().replace(/\s+/g, "-")}`);
  }
}

async function loadLeaderboard(mode) {
  const { data, error } = await supabase
    .from("leaderboard")
    .select("name, score")
    .eq("mode", mode)
    .order("score", { ascending: false })
    .limit(10);

  if (error) {
    console.error(`‚ùå Error loading ${mode} leaderboard:`, error);
    return [];
  }

  return data;
}

document.getElementById("leaderboardModal")
  .addEventListener("show.bs.modal", () => {
    renderLeaderboard("Classic", "leaderboard-classic-body");
    renderLeaderboard("Hurry Hurry", "leaderboard-hurry-body");
    renderLeaderboard("Dizzy Dizzy", "leaderboard-dizzy-body");
    renderLeaderboard("Swish and Match", "leaderboard-swish-body");
  });

async function renderLeaderboard(mode, containerId) {
  const scores = await loadLeaderboard(mode);
  const container = document.getElementById(containerId);

  container.innerHTML = scores.length > 0
    ? `
      <table class="table table-sm table-striped text-center align-middle">
        
        <tbody>
          ${scores.map((s, i) =>
            `<tr>
               <td>${i === 0 ? "ü•á" : i === 1 ? "ü•à" : i === 2 ? "ü•â" : i + 1}</td>
               <td>${s.name}</td>
               <td>${s.score}</td>
             </tr>`
          ).join("")}
        </tbody>
      </table>
    `
    : "<p><em>No scores yet</em></p>";
}

// Load all leaderboards when modal opens


</script>

</body>
</html>
